<p><link rel="stylesheet" type="text/css" href="global.css"></p>
<p><link rel="stylesheet" href="highlight.css"></p>
<h1 id="todo-mvc-application">ToDo MVC Application</h1>
<p>We will demonstrate how to create a Scalejs application by creating a ToDo MVC app. Scalejs is better suited for creating large and scalable applications, but we will cover some basics with the ToDo MVC app such as:</p>
<ul>
<li>Composition of Modules</li>
<li>View, View Models, and Bindings</li>
<li>States and Routing</li>
</ul>
<h2 id="creating-the-project">Creating the Project</h2>
<p>Creating a new Scalejs project is simple. Once you <a href="./install.html">Install Scalejs</a>, 
you can create a Scalejs project by simply selecting the template for a 
<strong>Scalejs MVVM Application (CSS)</strong> from the project creation template.</p>
<p>For this tutorial we will use the CSS template. LESS will be covered in another tutorial. </p>
<p><img src="./project1.png" alt="Scalejs MVVM Application is listed under &#39;Visual C#&#39; templates"></p>
<p>Every Scalejs Project has a similar file structure (as seen below) 
which is explained in more details in <a href="./overview.html">Explanation and Overview</a>  for more details.  </p>
<p><img src="./project2.png" alt="Files generated by project template"></p>
<p>Your application code, which we will be editting in this tutorial, is within the <em>app</em> folder. 
This folder contains the <a href="./overview.html#modules">modules</a> for your project. 
A module contains <a href="./bindings.html">bindings</a>, <a href="./overview.html#viewmodels">viewmodels</a>,
<a href="./overview.html#styles">styles</a> and <a href="./overview.html#views">views</a> for your project. </p>
<p>To view and run the project, simply press <strong>ctrl + f5</strong>. Then open a browser with a <a href="./best.html#debug">debugging console</a>(press F12 to open)
and navigate to <a href="http://localhost:8888">http://localhost:8888</a> to see it in action!</p>
<p>!!UPDATE THIS PICTURE!!
<img src="./helloworld.png" alt="Hello World!"></p>
<p><em>Scalejs MVVM Application template is a working Hello World! Sample. <a href="./hello.html">See how Hello World works!</a></em></p>
<h2 id="designing-todomvc-application">Designing ToDoMVC Application</h2>
<p>ToDo MVC application already has well defined <a href="./linktospec">specification and design guidelines</a>. 
Typically scalejs is used to create modular applications. Even though we do not need this for ToDoMVC
because it is so simple, we will show you to do it in a modular fashion.</p>
<p>A module is self-containing, independent, reusable component of your web application. Modules are loosely-coupled
meaning they do not depend on other modules. Modules contain views, viewmodels, styles, and bindings, which we will 
go over in more detail as we create the app.</p>
<p>Typically scalejs apps consist of a <em>main</em> module will be responsible for the <a href="./overview.html#layout">layout</a>
and other functional modules. An example of a functional module is the <em>todo</em> module because it will be responsible 
for functional aspect of the application.</p>
<p><img src="./todo.png" alt="ToDo App consists of two modules: main and todo"></p>
<p>You can take a look at our other <a href="./samples.html">samples</a> to see what a more complex app might look like.</p>
<h2 id="main-module">Main Module</h2>
<p>The main module will consist of a <a href="./overview.html#views">view</a>, <a href="./overview.html#viewmodel">viewmodel</a>, 
<a href="./overview.html#bindings">bindings</a> and <a href="./overview.html#styles">styles</a>.</p>
<p>The <strong>view</strong> defines templates.</p>
<p>The <strong>viewmodel</strong> performs logical tasks, and exposes properties to the view.</p>
<p>The <strong>bindings</strong> define what is bound to an element with a certain data class.</p>
<p>The <strong>styles</strong> contain the .css files which are needed for the module</p>
<p>A Scalejs project generates modules which already include the view, viewmodel, bindings and styles.</p>
<h3 id="main-view">Main View</h3>
<p>The <em>main</em> module in our app we define the layout, so our view will mostly be a placeholder for other
templates to render themselves inside of it. The <em>view</em> is an html file in the <strong>views</strong> folder.</p>
<p>A <em>template</em> is a parentless div in an html file within your <em>views</em> folder that has an id with the postfix &#39;<em>template&#39;.
We only need to define one template for _main</em>. </p>
<p><strong>main/views/main.html</strong></p>
<pre><code class="lang-xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"main_template"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"todoapp"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">header</span> <span class="attribute">id</span>=<span class="value">"header"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">h1</span>&gt;</span>todos<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
        <span class="comment">&lt;!-- we need to reference todo input here --&gt;</span>
        <span class="tag">&lt;/<span class="title">header</span>&gt;</span>
        <span class="comment">&lt;!-- we need to reference todo items here --&gt;</span>
    <span class="tag">&lt;/<span class="title">section</span>&gt;</span>
    <span class="tag">&lt;<span class="title">footer</span> <span class="attribute">id</span>=<span class="value">"info"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">p</span>&gt;</span>Double-click to edit a todo<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">footer</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span></code></pre>
<p>Our layout references two templates from the <em>todo</em> module: the input and the items. We split it up this way
so that our <em>main</em> module also has control over the header &quot;todos&quot; and the todo module is soley responsible for
the funtionality of creating, showing, editting, and removing todos.</p>
<p>In order to render the templates from the todo module, there are a few things we need to do.
We use a <a href="./mvvm.html#virtual">virtual binding</a> to tell the main template to render whatever template is given
to it in that place. We use <a href="http://knockoutjs.com/">knockoutjs</a> to the binding, 
and here we are using the <a href="./mvvm.html#render">render</a> binding. It is not much different than 
knockout&#39;s <a href="./mvvm.html#template">template</a> binding but it takes an <a href="./mvvm.html#observable">observable</a> so that
we can define the template which will be given to it at a later time. We could also change the template which is 
rendered here easily with this binding. </p>
<p>The reason we use a virtual binding is because we do not want to create a new html element; we just want to take 
the contents of our template and render it here. We use observables because when you update an observable, it 
automatically updates the view, as well.</p>
<p><strong>main/views/main.html</strong></p>
<pre><code class="lang-xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"main_template"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"todoapp"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">header</span> <span class="attribute">id</span>=<span class="value">"header"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">h1</span>&gt;</span>todos<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
            <span class="comment">&lt;!-- ko render:todoInput--&gt;</span>
            <span class="comment">&lt;!-- /ko --&gt;</span>
        <span class="tag">&lt;/<span class="title">header</span>&gt;</span>
        <span class="comment">&lt;!-- ko render:todoItems --&gt;</span>
        <span class="comment">&lt;!-- /ko --&gt;</span>
    <span class="tag">&lt;/<span class="title">section</span>&gt;</span>
    <span class="tag">&lt;<span class="title">footer</span> <span class="attribute">id</span>=<span class="value">"info"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">p</span>&gt;</span>Double-click to edit a todo<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">footer</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span></code></pre>
<p>We have created the view, however, if you were to run the app, you would see an error.</p>
<p>Press <strong>ctrl+f5</strong> to build the project and run IISExpress. 
See it in action in your browser at <a href="http://localhost:8888">http://localhost:8888</a>, and open the debugging console
(press <strong>F12</strong>) to see the following:</p>
<p><img src="./error1.png" alt="It doesn&#39;t work :("></p>
<p>We can fix this problem in the viewmodel.</p>
<h3 id="main-viewmodel">Main ViewModel</h3>
<p>Since we have referenced <code>todoInput</code> and <code>todoItems</code>, we have to define them in the <a href="./overview.html#viewmodels">viewmodel</a></p>
<p><strong>main/viewmodels/mainViewModel.js</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
define([
    <span class="string">'sandbox!main'</span>
], <span class="function"><span class="keyword">function</span> <span class="params">(
    sandbox
)</span> {</span>
    <span class="string">'use strict'</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> <span class="comment">// imports</span>
            observable = sandbox.mvvm.observable,
            <span class="comment">// properties</span>
            todoItems = observable(),
            todoInput = observable();

        <span class="keyword">return</span> {
            todoItems: todoItems,
            todoInput: todoInput
        };
    };
});</code></pre>
<p>We need to return <code>todoItems</code> and <code>todoInput</code> from the viewmodel or because
we need to access it within our module and our view. If we don&#39;t return these, 
then they becme private variables within the viewmodel and they cnanot be seen by
other viewmodels, modules, and bindings.</p>
<p>We made these properties observables which are bound to the &#39;render&#39; binding in the main template. 
The render binding expects a template to be passed to it. This template comes from the <em>todo</em> module, 
but in order for the <em>todo</em> module to access these observables, we need to expose it in the <a href="./overview.html#statechart">statechart</a>. </p>
<h3 id="main-statechart">Main Statechart</h3>
<p>The statechart allows modules to be agnostic to eachother, so that the main module does not need to know any
details about the <em>todo</em> module or vice versa. They only need to know about the statechart, which is always
going to be more specific to your application, as it controls the state of the application.</p>
<p>The state chart consists of two things: states and transitions. When we transition to a state, we defind the
state within the <code>onEntry</code> transition. We also can listen for events (which are called with <code>raise</code>) and
transition to the appropriate state based upon that. States can have parent or children states, as well as parallel
states so your application can be in multiple states at one time. For example, our router is a parallel state and
we will discuss routing later on.</p>
<p>Adding properties to the statechart is very simple; the statechart object is exposed via <code>this</code> within the functions
passed to the statechart (e.g., <code>onEntry</code>). The statechart object is shared between all states in all the modules.
It is the only place where we can break the pattern of loose-coupling between modules, so use it sparsely and
only when it is appropriate.</p>
<p><strong>main/manModule.js</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
define([
    <span class="string">'sandbox!main'</span>,
    <span class="string">'app/main/viewmodels/mainViewModel'</span>,
    <span class="string">'views!main'</span>,
    <span class="string">'bindings!main'</span>,
    <span class="string">'styles!main'</span>
], <span class="function"><span class="keyword">function</span> <span class="params">(
    sandbox,
    mainViewModel
)</span> {</span>
    <span class="string">'use strict'</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> <span class="comment">// imports</span>
            root = sandbox.mvvm.root,
            template = sandbox.mvvm.template,
            registerStates = sandbox.state.registerStates,
            state = sandbox.state.builder.state,
            onEntry = sandbox.state.builder.onEntry,
            <span class="comment">// vars</span>
            mainVM = mainViewModel();

        <span class="comment">// Register application state for the module.</span>
        registerStates(<span class="string">'root'</span>,
            state(<span class="string">'app'</span>,
                state(<span class="string">'main'</span>,
                    onEntry(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                        <span class="comment">// create state properties for rendering todo module templates</span>
                        <span class="keyword">this</span>.todoItems = mainVM.todoItems;
                        <span class="keyword">this</span>.todoInput = mainVM.todoInput;
                        <span class="comment">// Render viewModel using 'main_template' template </span>
                        <span class="comment">// (defined in main.html) and show it in the `root` region.</span>
                        root(template(<span class="string">'main_template'</span>, mainVM));
                    }))));
    };
});</code></pre>
<p><em>Note: We renamed</em> <code>viewModel</code> <em>to</em> <code>mainVM</code> <em>to avoid ambiguity</em></p>
<p>When we create the <em>todoItems</em> and <em>todoInput</em> properties, we assign them to an empty observable. 
This observable can now be accessed and updated by another module, but main doesn&#39;t know anything about this 
other module � preserving the pattern of &quot;loosely coupled&quot; modules. Even though the <em>todo</em> module has to
pass its templates to these observables, it doesn&#39;t know anything about the <em>main</em> module other
than what is explictly shared via state.</p>
<p>If IIS Express is still running, refresh your browser. If its not running, again, 
press <strong>CTRL + F5</strong> to start it up on <a href="http://localhost:8888">http://localhost:8888</a>.
You will find that the errors are gone, but unfortunately it is not styled. However,
functionally we are done with the <em>main</em> module. We did not need to declare bindings because we used <code>data-bind</code>, 
but we will be using <code>data-class</code> in some instances within the <em>todo</em> module so that is when we will be creating
bindings.</p>
<p><img src="./app1.png" alt="Main module sans styles"></p>
<h3 id="main-styles">Main Styles</h3>
<p>Styling main is simple and straight-forward. We used the <a href="linktocss">css</a> that was provided by the <a href="linktodo">todomvc</a>
specification. We will just copy-and-paste the contents of this css file into <strong>main.css</strong> which is located in the
<strong>styles</strong> folder. In a future tutorial, we will cover how to use LESS in your modules.</p>
<p><img src="./app1.png" alt="Main module with styles"></p>
<h2 id="creating-the-todo-module">Creating the todo Module</h2>
<p>To make a new module is extremely easy with scalejs due to the Visual Stuido Item templates
for modules. <strong>Right-click</strong> on the <strong>app</strong> folder and select <strong>Add &gt; New Item.</strong>
From the Add New Item window, search for <em>scalejs</em> and select the 
<strong>Scalejs MVVM Module (CSS)</strong>. Name this module <em>todo</em> and click <strong>Add</strong>.</p>
<p><img src="./module1.png" alt="Creating a new Module"></p>
<p>Once we create a module we need include it in the <strong>app.js</strong> file. </p>
<pre><code class="lang-javascript">require([
    <span class="string">'scalejs!application/main,todo'</span>
], <span class="function"><span class="keyword">function</span> <span class="params">(
    application
)</span> {</span>
    <span class="string">'use strict'</span>;

    application.run();
});</code></pre>
<p>We also need to modify <strong>todoModule.js</strong> so that we are creating the correct statechart. Right now, the
<em>todo</em> state is being added as a child to the <em>app</em> state. Since the <em>main</em> state is also a child of the <em>app</em> state,
the app can only be in either th <em>main</em> state or the <em>todo</em> state at a single time. If the <em>main</em> module is initialized
before the <em>todo</em> module, the app will enter its <em>main</em> state and never reach the <em>todo</em> state. If <em>todo</em> is initialized
before <em>main</em>, then it will try to access properities on the statechart which do not exist yet. This is because
when a state has multiple children states, it will  enter the first state which is defined. </p>
<p>Our statechart, then, looks like this</p>
<p><img src="./statechart1.png" alt="Bad statechart"></p>
<p>To remedy this, we can make <em>todo</em> a child of the <em>main</em> state by changing the statechart in <strong>todoModule.js</strong>.</p>
<p><strong>todo/todoModule.js</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
define([
    <span class="string">'sandbox!todo'</span>,
    <span class="string">'app/todo/viewmodels/todoViewModel'</span>,
    <span class="string">'bindings!todo'</span>,
    <span class="string">'views!todo'</span>,
    <span class="string">'styles!todo'</span>
], <span class="function"><span class="keyword">function</span> <span class="params">(
    sandbox,
    todoViewModel
)</span> {</span>
    <span class="string">'use strict'</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">todoModule</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> <span class="comment">// imports</span>
            root = sandbox.mvvm.root,
            template = sandbox.mvvm.template,
            registerStates = sandbox.state.registerStates,
            state = sandbox.state.builder.state,
            onEntry = sandbox.state.builder.onEntry,
            <span class="comment">// vars</span>
            todo = todoViewModel(sandbox);

        <span class="comment">// Register application state for the module.</span>
        registerStates(<span class="string">'main'</span>,
            state(<span class="string">'todo'</span>,
                onEntry(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                    <span class="comment">// Render viewModel using 'main_template' template </span>
                    <span class="comment">// (defined in main.html) and show it in the `root` region.</span>
                    todo.text(<span class="string">'Hello World from todo!'</span>);
                    root(template(<span class="string">'todo_template'</span>, todo));
                })));
    };
});</code></pre>
<p>Now we have created this statechart.</p>
<p><img src="./statechart2" alt="Good Statechart"></p>
<p>Now we will cover the view for this module so that we can see our todos.</p>
<h3 id="todo-view">Todo View</h3>
<p>The view for <em>todo</em> follows the same concept as the view for <em>main</em> except now we have 2 templates: one for the 
todo list, and the other for the todo input. The template for the list is a little more complex than the
one for main. For now, we won&#39;t add any bindings, because as we add functionality to our app, our views, viewmodels,
and bindings will evolve into more.</p>
<p>For now all we need to do is define the template so they can be rendered observables that were created in <em>main</em>
and added to the statechart.</p>
<pre><code class="lang-xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"todo_items_template"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"main"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"toggle-all"</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"toggle-all"</span>&gt;</span>Mark all as complete<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
        <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"todo-list"</span>&gt;</span>
            <span class="comment">&lt;!-- These are here just to show the structure of the list items --&gt;</span>
            <span class="comment">&lt;!-- List items should get the class `editing` when editing and `completed` when marked as completed --&gt;</span>
            <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"completed"</span>&gt;</span>
                <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"view"</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"toggle"</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">checked</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">label</span>&gt;</span>Create a TodoMVC template<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">class</span>=<span class="value">"destroy"</span>&gt;</span><span class="tag">&lt;/<span class="title">button</span>&gt;</span>
                <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
                <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"edit"</span> <span class="attribute">value</span>=<span class="value">"Create a TodoMVC template"</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
            <span class="tag">&lt;<span class="title">li</span>&gt;</span>
                <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"view"</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"toggle"</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">label</span>&gt;</span>Rule the web<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">class</span>=<span class="value">"destroy"</span>&gt;</span><span class="tag">&lt;/<span class="title">button</span>&gt;</span>
                <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
                <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"edit"</span> <span class="attribute">value</span>=<span class="value">"Rule the web"</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">section</span>&gt;</span>
    <span class="comment">&lt;!-- This footer should hidden by default and shown when there are todos --&gt;</span>
    <span class="tag">&lt;<span class="title">footer</span> <span class="attribute">id</span>=<span class="value">"footer"</span>&gt;</span>
        <span class="comment">&lt;!-- This should be `0 items left` by default --&gt;</span>
        <span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"todo-count"</span>&gt;</span><span class="tag">&lt;<span class="title">strong</span>&gt;</span>1<span class="tag">&lt;/<span class="title">strong</span>&gt;</span> item left<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
        <span class="comment">&lt;!-- Remove this if you don't implement routing --&gt;</span>
        <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"filters"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">li</span>&gt;</span>
                <span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"selected"</span> <span class="attribute">href</span>=<span class="value">"#/"</span>&gt;</span>All<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
            <span class="tag">&lt;<span class="title">li</span>&gt;</span>
                <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#/active"</span>&gt;</span>Active<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
            <span class="tag">&lt;<span class="title">li</span>&gt;</span>
                <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#/completed"</span>&gt;</span>Completed<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
        <span class="comment">&lt;!-- Hidden if no completed items are left --&gt;</span>
        <span class="tag">&lt;<span class="title">button</span> <span class="attribute">id</span>=<span class="value">"clear-completed"</span>&gt;</span>Clear completed (1)<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">footer</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>

<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"todo_input_template"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"new-todo"</span> <span class="attribute">placeholder</span>=<span class="value">"What needs to be done?"</span> <span class="attribute">autofocus</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span></code></pre>
<p>Right now in the <em>todo</em> state we are passing the template (which no longer have defined within our view) to the
<code>root</code> which is wrong. Instead we should be passing the <code>todo_items_template</code> and the <code>todo_input_template</code> 
into the <code>todoItems</code> and <code>todoInput</code> observables we defined in the <em>main</em> state.</p>
<p><strong>todo/todoModule.js</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
define([
    <span class="string">'sandbox!todo'</span>,
    <span class="string">'app/todo/viewmodels/todoViewModel'</span>,
    <span class="string">'bindings!todo'</span>,
    <span class="string">'views!todo'</span>,
    <span class="string">'styles!todo'</span>
], <span class="function"><span class="keyword">function</span> <span class="params">(
    sandbox,
    todoViewModel
)</span> {</span>
    <span class="string">'use strict'</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">todoModule</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> <span class="comment">// imports</span>
            template = sandbox.mvvm.template,
            registerStates = sandbox.state.registerStates,
            state = sandbox.state.builder.state,
            onEntry = sandbox.state.builder.onEntry,
            <span class="comment">// vars</span>
            todo = todoViewModel(sandbox);

        <span class="comment">// Register application state for the module.</span>
        registerStates(<span class="string">'main'</span>,
            state(<span class="string">'todo'</span>,
                onEntry(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                    <span class="comment">// pass the template bindings to the appropriate property</span>
                    <span class="keyword">this</span>.todoItems(template(<span class="string">'todo_items_template'</span>, todo));
                    <span class="keyword">this</span>.todoInput(template(<span class="string">'todo_input_template'</span>, todo));
                })));
    };
});</code></pre>
<p>This is all you need to display the <em>todo</em> module in your app. Now if you refresh
your browser you will see a static version of the <em>todo</em> module. </p>
<p><img src="./todo1.png" alt="A Useless Web App!"></p>
<h2 id="functionality">Functionality</h2>
<p>The static app might look good, but as you can tell by clicking on it is completely
useless. We can fix this by adding functionality which we will do in incremental
steps so that you are able to follow along.</p>
<h3 id="hide-main-and-footer-when-there-are-none">Hide main and footer when there are none</h3>
<p>According to the spec, the element with the id <em>#main</em> and the element with the id <em>#footer</em>
Must be hidden when there are no todos. To do this we need to have a data structure
to store the todos. We need to be able to know how many items are in this structure.
We also need to be able to add and remove items. Since we will be showing todos in our 
view, the view must be able to react to the changes in the structure.</p>
<p>To accomplish all of this we will use an <strong>observableArray</strong> to store the items. 
If you are familiar with knockout.js this should be easy to do, but if not you can
learn about them in more detail <a href="./mvvm.html#obseravles">here</a>. We define this
in our viewmodel (<strong>todoViewModel.js</strong>) is where we will create this property.</p>
<p>In order to use <code>observableArray</code> in our code, we import it from the <code>sandbox</code> by 
setting it to a var at the top of our module. The <code>sandbox</code> is where extensions can
place themselves and expose functions for modules to use. The <code>sandbox</code> allows  modules
to access these extensions in a sandboxed manner, so no module has access to another
modules&#39; sandbox.  <code>observableArray</code> is included in the <code>mvvm</code> extension. You can learn
more about the <a href="./overview.html#sandbox">sandbox</a> and the <a href="./mvvm.html">mvvm extension</a>
in our docs. </p>
<p>One of the great benefits to scalejs is that we have <a href="./best.html#intellisense">intellisense</a>
for all of extensions and functions in the sandbox. Keep a look out for what happens as 
you add functions from the sandbox to your app, and feel free to take a peek at what is 
exposed on the sandbox with the handy dandy intellisense.</p>
<p><strong>todo/viewmodels/todoViewModel.js</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
define([
    <span class="string">'sandbox!todo'</span>
], <span class="function"><span class="keyword">function</span> <span class="params">(
    sandbox
)</span> {</span>
    <span class="string">'use strict'</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> observableArray = sandbox.mvvm.observableArray,
            <span class="comment">//properties</span>
            items = observableArray();

        <span class="keyword">return</span> {
            items: items
        };
    };
});</code></pre>
<p>We need to hide <code>#main</code> and <code>#footer</code> if this array is empty. 
Wwe can do this by defining a special data-class. 
To add a data-class to an element in your template is very simple and straightforward. 
We will add the data-class <code>todo-visible</code> in the <code>todo_items_template</code>.</p>
<p><strong>todo/views/todo.html</strong></p>
<pre><code class="lang-xml"><span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"main"</span> <span class="attribute">data-class</span>=<span class="value">"todo-visible"</span>&gt;</span>
...
<span class="tag">&lt;<span class="title">footer</span> <span class="attribute">id</span>=<span class="value">"footer"</span> <span class="attribute">data-class</span>=<span class="value">"todo-visible"</span>&gt;</span></code></pre>
<p>The reason we use data-class instead of data-bind is so that we can define the data-class in our bindings file,
which will allow us the reuse the same binding without having to rewrite it.</p>
<p>Now we can define the logic behind the <code>todo-visible</code> data-class in <strong>todoBindings.js</strong>.</p>
<p><strong>todo/bindings/todoBindings.js</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
<span class="comment">/*jslint sloppy: true*/</span>
define({
    <span class="string">'todo-visible'</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> {
            visible: <span class="keyword">this</span>.items().length &gt; <span class="number">0</span>
        };
    }
});</code></pre>
<p>After saving these files, refresh the browsers to observe the appropriate divs being hidden.</p>
<p><img src="./todohidden.png" alt="Nothing to do!"></p>
<h3 id="adding-a-new-todo">Adding a new todo</h3>
<p>We need to let the user input a value and when they hit enter, add it to the list.
For this functionality, we need to bind the input to a new observable. Let&#39;s call it <em>newItem</em>.</p>
<p><strong>todo/viewmodels/todoViewModel.js</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
define([
    <span class="string">'sandbox!todo'</span>
], <span class="function"><span class="keyword">function</span> <span class="params">(
    sandbox
)</span> {</span>
    <span class="string">'use strict'</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> observable = sandbox.mvvm.observable,
            observableArray = sandbox.mvvm.observableArray,
            <span class="comment">//properties</span>
            items = observableArray(),
            newItem = observable();

        <span class="keyword">return</span> {
            items: items,
            newItem: newItem
        };
    };
});</code></pre>
<p>This must be added to the <em>value</em> binding of the input box so that as the user types,
the observale gets updated with what they type. We also need to instruct this observable
to update whenever a user hits a key (<code>afterkeydown</code> event) and to listen for the
<code>ENTER_KEY</code> so that it can add the value in <code>newItem</code> to the <code>items</code> array.</p>
<p>Because we need to do so much with this input, we will assign a  data-class 
to it and name it <code>todo-input</code>. This time, we are using a data-class because
there are so many bindings on this element and it will be cleaner to define
them outside of the html.</p>
<p><strong>todo/views/todo.html</strong></p>
<pre><code class="lang-xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"todo_input_template"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"new-todo"</span> <span class="attribute">data-class</span>=<span class="value">"todo-input"</span> <span class="attribute">placeholder</span>=<span class="value">"What needs to be done?"</span> <span class="attribute">autofocus</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span></code></pre>
<p>As for <code>todo-visible</code>, we must also add a definition for this class in <strong>todoBindings.js</strong></p>
<p><strong>todo/bindings/todoBindings.html</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
<span class="comment">/*jslint sloppy: true*/</span>
define({
    <span class="string">'todo-visible'</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> {
            visible: <span class="keyword">this</span>.items().length &gt; <span class="number">0</span>
        };
    },
    <span class="string">'todo-input'</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> {
            value: <span class="keyword">this</span>.newItem,
            valueUpdate: <span class="string">'afterkeydown'</span>
        };
    }
});</code></pre>
<p>With these bindings, we are listening for user input and updating <code>newItem</code> whenever
the user presses a key.</p>
<p>You might be wondering a few things about how <a href="./bindings.html">bindings</a> work.
<code>this</code> contains a reference to the viewmodel within the context of this binding.
Usually this is the viewmodel for the module, but in some cases (such as the <a href=".mvvm.html#foreach">foreach</a> binding)
it will be something else. We will explain this in more detail when we implement
displaying the todos in a list.</p>
<p>Also, we are prefixing all of our data-class names with the name of the module 
(e.g. <em>todo-</em>) because we want to make it cleaner for a developer to know what module a 
data-class belongs to by looking at its class name.</p>
<p>Now we need to add the logic so that when one presses enter a new todo is added to the list. 
First lets create a function in <strong>todoViewModel.js</strong> to do so. We will call it <code>addItem</code>.</p>
<p><strong>todo/viewmodels/todoViewModel.js</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
define([
    <span class="string">'sandbox!todo'</span>
], <span class="function"><span class="keyword">function</span> <span class="params">(
    sandbox
)</span> {</span>
    <span class="string">'use strict'</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> observable = sandbox.mvvm.observable,
            observableArray = sandbox.mvvm.observableArray,
            has = sandbox.object.has,
            <span class="comment">//properties</span>
            items = observableArray(),
            newItem = observable();

        <span class="function"><span class="keyword">function</span> <span class="title">addItem</span><span class="params">()</span> {</span>
            <span class="keyword">var</span> item = newItem();
            <span class="keyword">if</span> (has(item, <span class="string">"trim"</span>) &amp;&amp; item.trim()) {
                items.push(item.trim());
            }
            newItem(<span class="string">""</span>);
        }

        <span class="keyword">return</span> {
            items: items,
            newItem: newItem,
            addItem: addItem
        };
    };
});</code></pre>
<p>You can implement <code>addItem</code> whichever way you please, but in ours we use the <a href="./api.html#has">has</a> function so
be sure to include it from the sandbox. <code>has</code> can be found in the <code>object</code> namespace and we
use it to make sure that the item has the &#39;trim&#39; function before we attempt to call it.</p>
<p>The next step is making sure this function gets called when the user hits enter. We can do that by defining an
event binding in the <code>todo-input</code> data-class we defined from before.</p>
<p><strong>todo/bindings/todoBindings.js</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
<span class="comment">/*jslint sloppy: true,unparam: true*/</span>
define(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> ENTER_KEY = <span class="number">13</span>;
    <span class="keyword">return</span> {
        <span class="string">'todo-visible'</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> {
                visible: <span class="keyword">this</span>.items().length &gt; <span class="number">0</span>
            };
        },
        <span class="string">'todo-input'</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">var</span> addItem = <span class="keyword">this</span>.addItem;
            <span class="keyword">return</span> {
                value: <span class="keyword">this</span>.newItem,
                valueUpdate: <span class="string">'afterkeydown'</span>,
                event: {
                    keyup: <span class="function"><span class="keyword">function</span> <span class="params">(data, e)</span> {</span>
                        <span class="keyword">if</span> (e.keyCode === ENTER_KEY) {
                            addItem();
                        }
                    }
                }
            };
        }
    };
});</code></pre>
<p>Since we defined a function for the event, we lost the context of the outer function so we 
cannot use <em>this</em> to get our viewModel properties. To fix this we define a var at the top of the data-class
with the same name as the function 
we want to use (<code>addItem</code>) and assigned the function defined in �this� to the var.</p>
<p>We also converted our bindings object to a function which will =return the bindings object, so that we can define
&#39;global&#39; vars (which are local to the function containing the bindings) so we can reuse constants like <code>ENTER_KEY</code>
in our bindings. We will need it again for editting an item, so it&#39;s good to do this now.</p>
<p>If you refresh the page now and try adding an item, you will see that entering
an item and will clear the input and show some todos, but since we haven&#39;t
implemented showing todos it won&#39;t actually display the todo you just entered.</p>
<h3 id="displaying-todos-in-the-list">Displaying todos in the list</h3>
<p>We need to make sure the todos are being displayed in the list.
Right now we�re not binding the list to anything � but the fix is very simple. 
We can bing the <code>ul</code> element to the items array using the <code>foreach</code> bidning. The contents
of the <code>ul</code> will be repeated for each item in the list, with the item providing the 
context for the binding.</p>
<p><strong>todo/views/todo.html</strong></p>
<pre><code class="lang-xml">    <span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"main"</span> <span class="attribute">data-class</span>=<span class="value">"todo-visible"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"toggle-all"</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"toggle-all"</span>&gt;</span>Mark all as complete<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
        <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"todo-list"</span> <span class="attribute">data-bind</span>=<span class="value">"foreach: items"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"completed"</span>&gt;</span>
                <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"view"</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"toggle"</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">checked</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">data-bind</span>=<span class="value">"text: $data"</span>&gt;</span><span class="tag">&lt;/<span class="title">label</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">class</span>=<span class="value">"destroy"</span>&gt;</span><span class="tag">&lt;/<span class="title">button</span>&gt;</span>
                <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
                <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"edit"</span> <span class="attribute">value</span>=<span class="value">"Create a TodoMVC template"</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">section</span>&gt;</span></code></pre>
<p>Instead of using a data-class we just used a regular binding like we did in the <code>main_template</code> with <code>render</code>. 
<code>foreach</code> is a knockout binding which will take the contents of the div and render it as a template for each
item within the array <code>foreach</code> is bound to. You can learn more about it <a href="http://knockoutjs.com/documentation/foreach-binding.html">here</a></p>
<p>After saving these files, refresh the browsers to observe the ability to add items to the list.</p>
<p><img src="./todo3.png" alt="Adding items to the list"></p>
<p>But this isn&#39;t enough. We also need to do a little extra work when adding an item so that it shows 
the completed class only when it is completed. To do this, we need to alter the item so
it is an object with two properties: <code>title</code> and <code>completed</code>.. 
In <strong>todoViewModel.js</strong> make the following change to the item when it is pushed to the items array.</p>
<p><strong>todo/viewmodels/todoViewModel.js</strong></p>
<pre><code class="lang-javascript">        <span class="function"><span class="keyword">function</span> <span class="title">addItem</span><span class="params">()</span> {</span>
            <span class="keyword">var</span> item = newItem();
            <span class="keyword">if</span> (has(item, <span class="string">"trim"</span>) &amp;&amp; item.trim()) {
                items.push({
                    title: item.trim(),
                    completed: observable(<span class="literal">false</span>)
                });
            }
            newItem(<span class="string">""</span>);
        }</code></pre>
<p>In <code>todo_items_template</code> also edit the li element so that it is being bound to the title
and the completed properties.</p>
<p><strong>todo/views/todo.html</strong></p>
<pre><code class="lang-xml">            <span class="tag">&lt;<span class="title">li</span> <span class="attribute">data-bind</span>=<span class="value">"css: { completed: completed }"</span>&gt;</span>
                <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"view"</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"toggle"</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">data-bind</span>=<span class="value">"checked: completed"</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">data-bind</span>=<span class="value">"text: title"</span>&gt;</span><span class="tag">&lt;/<span class="title">label</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">class</span>=<span class="value">"destroy"</span>&gt;</span><span class="tag">&lt;/<span class="title">button</span>&gt;</span>
                <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
                <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"edit"</span> <span class="attribute">value</span>=<span class="value">"Create a TodoMVC template"</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">li</span>&gt;</span></code></pre>
<p>Now the completed class is only added if the item&#39;s <code>completed</code>
property is true. At the same time, we are also able to toggle this class on and off when we check or uncheck 
the item because we have bound the checkbox input to the <code>checked</code> binding. Since <code>completed</code> is an observable, 
when we check the item, <code>completed</code> becomes true, so the css completed is applied to the list item.</p>
<p>After saving these files, refresh the browsers to observe that checking/unchecking the checkbox applies the 
appropriate class to the list item.</p>
<p><img src="./todo2.png" alt="Now we can add items to the todo list"></p>
<h3 id="mark-all-as-complete">Mark all as complete</h3>
<p>We need to mark all of the items as completed when we click on the arrow
to the left of the input box. We use a <code>computed</code> property to do this. Computed properties
are more complex than observables but are very useful once you understand them.
Tou can read more about computed properties <a href="linktocomputed">here</a>. </p>
<p>The computed will re-evaluate any time an observable within it changes. 
We can use this to react to the <code>items</code> and return true when are all checked
to indicate to the &#39;mark all as complete&#39; arrow that it should be &#39;checked&#39;</p>
<p><strong>todo/viewmodels/todoViewModel.js</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
define([
    <span class="string">'sandbox!todo'</span>
], <span class="function"><span class="keyword">function</span> <span class="params">(
    sandbox
)</span> {</span>
    <span class="string">'use strict'</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> observableArray = sandbox.mvvm.observableArray,
            observable = sandbox.mvvm.observable,
            has = sandbox.object.has,
            computed = sandbox.mvvm.computed,
            <span class="comment">//properties</span>
            items = observableArray(),
            newItem = observable(),
            checkAll;

        <span class="function"><span class="keyword">function</span> <span class="title">addItem</span><span class="params">()</span> {</span>
            <span class="keyword">var</span> item = newItem();
            <span class="keyword">if</span> (has(item, <span class="string">"trim"</span>) &amp;&amp; item.trim()) {
                items.push({
                    title: item.trim(),
                    completed: observable(<span class="literal">false</span>)
                });
            }
            newItem(<span class="string">""</span>);
        }

        checkAll = computed({
            read: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                <span class="keyword">return</span> items().all(<span class="string">"$.completed()"</span>);
            }
        });

        <span class="keyword">return</span> {
            items: items,
            newItem: newItem,
            addItem: addItem,
            checkAll: checkAll
        };
    };
});</code></pre>
<p>An interesting thing to note about our implementation of the <code>read</code> function is that we
are using <code>all</code> function which we get from <a href="linktolinq">linq.js</a>. Since scalejs is used
for large apps, we expect you will need to interact with arrays/lists/collections quite
often and will need more sophisticated functionality than what is provided by JavaScript.
This is why we expose all of linq&#39;s functions on the Array&#39;s prototype. </p>
<p>Wbind the computed property to the <code>toggle-all</code> checkbox like so:</p>
<p><strong>todo/views/todo.html</strong></p>
<pre><code class="lang-xml"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"toggle-all"</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">data-bind</span>=<span class="value">"checked: checkAll"</span>&gt;</span></code></pre>
<p>Now if you add a new item then mark it as complete, you will see the toggle-all 
checkbox is darker (e.g. it is checked). This checkbox will be checked if and
only if all the items in the list are checked. But if you click on this checkbox,
you are not able to change its value or update the items to be marked as completed
or not completed. We can fix this by giving this computed property a <code>write</code> function
which will take whever value it is given and apply it to all the items&#39; <code>completed</code> 
properties.</p>
<p><strong>todo/viewmodels/todoViewModel.js</strong></p>
<pre><code class="lang-javascript">        checkAll = computed({
            read: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                <span class="keyword">return</span> items().all(<span class="string">"$.completed()"</span>);
            },
            write: <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
                items().forEach(<span class="function"><span class="keyword">function</span> <span class="params">(item)</span> {</span> item.completed(value); });
            }
        });</code></pre>
<p>Now your app can mark/unmark all items as completed. Save and refresh to see it
in action.</p>
<h3 id="editting-a-todo">Editting a todo</h3>
<p>For this functionality we need to modify the <code>li</code> element a bit. We need to define a new
data-class for the element because we need to add more bindings and having any more than
1 binding on an html element looks ugly. We will give it the <code>todo-item</code> data-class.</p>
<p>We also need to add a data-class to the input element so that we can toggle editting on
and off. We will call this the <code>todo-edit</code> class.</p>
<p><strong>todo/views/todo.html</strong></p>
<pre><code class="lang-xml">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">data-class</span>=<span class="value">"todo-item"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"view"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"toggle"</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">data-bind</span>=<span class="value">"checked: completed"</span> /&gt;</span>
            <span class="tag">&lt;<span class="title">label</span> <span class="attribute">data-bind</span>=<span class="value">"text: title"</span>&gt;</span><span class="tag">&lt;/<span class="title">label</span>&gt;</span>
            <span class="tag">&lt;<span class="title">button</span> <span class="attribute">class</span>=<span class="value">"destroy"</span> <span class="attribute">data-bind</span>=<span class="value">"click: $parent.items.remove"</span>&gt;</span><span class="tag">&lt;/<span class="title">button</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"edit"</span> <span class="attribute">data-class</span>=<span class="value">"todo-edit"</span> /&gt;</span>
    <span class="tag">&lt;/<span class="title">li</span>&gt;</span></code></pre>
<p>In the <code>todo-item</code> data-class, not only to we need to repeat the binding we had previously
defined inline in the html, we also need to apply an <code>editting</code> class if the item is being 
edited. We begin editting an item when we double-click on an item, so we also bind a function 
called <code>beginEdit</code> to this event.</p>
<p>__todo/bindings/todoBindings.html</p>
<pre><code class="lang-javascript">    <span class="string">'todo-item'</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> {
                css: {
                    completed: <span class="keyword">this</span>.completed,
                    editing: <span class="keyword">this</span>.editMode
                },
                event: {
                    dblclick: <span class="keyword">this</span>.beginEdit
                }
            };
        },</code></pre>
<p>Since the <code>li</code> element is bound to an item, this means we have created two new properties
which need to be exposed on an item: <code>editMode</code> which is a boolean indicating if the item
is currently being editted, and <code>beginEdit</code> which is a function which will begin editting
on the item</p>
<p>The introduction of these two new properties on the item means that the item is getting
more and more complex. We also will need to add more properties and methods as we continue
to implement functionality, so the wise thing to do is give an item is own viewmodel.</p>
<p>We will define a new viewmodel in the <strong>viewmodels</strong> folder for <em>todo</em> and name it <strong>itemViewModel.js</strong>.
Copy and paste the code below or follow the pattern that the <em>main</em> and <em>todo</em> viewmodels use,
except do not declare any properties or return anything.</p>
<p><strong>todo/viewmodels/itemViewModel.js</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
define([
    <span class="string">'sandbox!todo'</span>
], <span class="function"><span class="keyword">function</span> <span class="params">(
    sandbox
)</span> {</span>
    <span class="string">'use strict'</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>

        <span class="keyword">return</span> {

        };
    };
});</code></pre>
<p>We will reference this viewmodel from the <strong>todoViewModel</strong> when we make a new item. 
We need to pass to this viewmodel the title of the item and the status of its
completion (when we create an item, it will always be false - but making
this a parameter will come in handy when we implement persistance)</p>
<p><strong>todo/viewmodels/todoViewModel.js</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
define([
    <span class="string">'sandbox!todo'</span>,
    <span class="string">'app/todo/viewmodels/itemViewModel'</span>
], <span class="function"><span class="keyword">function</span> <span class="params">(
    sandbox,
    itemViewModel
)</span> {</span>
    <span class="string">'use strict'</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> observableArray = sandbox.mvvm.observableArray,
            observable = sandbox.mvvm.observable,
            has = sandbox.object.has,
            computed = sandbox.mvvm.computed,
            <span class="comment">//properties</span>
            items = observableArray(),
            newItem = observable(),
            checkAll;

        <span class="function"><span class="keyword">function</span> <span class="title">addItem</span><span class="params">()</span> {</span>
            <span class="keyword">var</span> item = newItem();
            <span class="keyword">if</span> (has(item, <span class="string">"trim"</span>) &amp;&amp; item.trim()) {
                items.push(itemViewModel({ title: item, completed: <span class="literal">false</span> }));
            }
            newItem(<span class="string">""</span>);
        }</code></pre>
<p>Now we can recreate the functionality from before, and also add the new properties <code>editMode</code> and <code>beginEdit</code></p>
<p><strong>todo/viewmodels/itemViewModel.js</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
define([
    <span class="string">'sandbox!todo'</span>
], <span class="function"><span class="keyword">function</span> <span class="params">(
    sandbox
)</span> {</span>
    <span class="string">'use strict'</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(item)</span> {</span>
        <span class="keyword">var</span> observable = sandbox.mvvm.observable,
            <span class="comment">//properties</span>
            title = observable(item.title),
            completed = observable(item.completed),
            editMode = observable(<span class="literal">false</span>);

        <span class="function"><span class="keyword">function</span> <span class="title">beginEdit</span><span class="params">()</span> {</span>
            editMode(<span class="literal">true</span>);
        }

        <span class="keyword">return</span> {
            title: title,
            completed: completed,
        editMode: editMode,
            beginEdit: beginEdit
        };
    };
});</code></pre>
<p>This time, we made <code>title</code> an observable because when we are editting an item, presumably
we will need to change its title. <code>beginEdit</code> simply sets he <code>editMode</code> observable to true.</p>
<p>Beginning an edit is rather useless if we are unable to end it. To do this, we now will 
define the data-class <code>todo-edit</code> to listen for user input, update the value of title, and
end edit mode.</p>
<p><strong>todo/bindings/todoBindings.js</strong></p>
<pre><code class="lang-javascript">        <span class="string">'todo-edit'</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">var</span> item = <span class="keyword">this</span>;

            <span class="keyword">return</span> {
                value: <span class="keyword">this</span>.title,
                valueUpdate: <span class="string">'afterkeydown'</span>,
                event: {
                    keyup: <span class="function"><span class="keyword">function</span> <span class="params">(data, e)</span> {</span>
                        <span class="keyword">if</span> (e.keyCode === ENTER_KEY) {
                            item.endEdit();
                        }
                    }
                },
                hasFocus: <span class="keyword">this</span>.editMode
            };
        }</code></pre>
<p><code>value</code> and <code>valueUpdate</code> should be ring a bell. <code>hasFocus</code> is bound to the <code>editMode</code> property
so that when <code>editMode</code> is entered, the input automatically is given focus. <code>endEdit</code> still
needs to be defined in order for this to come full-circle.</p>
<p><strong>todo/viewmodels/itemViewModel.js</strong></p>
<pre><code class="lang-javascript"><span class="comment">/*global define */</span>
define([
    <span class="string">'sandbox!todo'</span>
], <span class="function"><span class="keyword">function</span> <span class="params">(
    sandbox
)</span> {</span>
    <span class="string">'use strict'</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(item)</span> {</span>
        <span class="keyword">var</span> observable = sandbox.mvvm.observable,
            <span class="comment">//properties</span>
            title = observable(item.title),
            completed = observable(item.completed),
            editMode = observable(<span class="literal">false</span>);

        <span class="function"><span class="keyword">function</span> <span class="title">beginEdit</span><span class="params">()</span> {</span>
            editMode(<span class="literal">true</span>);
        }

        <span class="function"><span class="keyword">function</span> <span class="title">endEdit</span><span class="params">()</span> {</span>
            <span class="keyword">var</span> newTitle = title().trim();
            <span class="keyword">if</span> (newTitle) {
                title(newTitle);
                editMode(<span class="literal">false</span>);
            } <span class="keyword">else</span> {
                <span class="comment">//we need to remove the item</span>
                <span class="comment">//if the title is an empty array</span>
            }
        }

        <span class="keyword">return</span> {
            title: title,
            completed: completed,
        editMode: editMode,
            beginEdit: beginEdit,
            endEdit: endEdit
        };
    };
});</code></pre>
<p>Now you can edit an item by double clicking on it, entering a new title, and hitting &#39;enter&#39;. </p>
