<link rel="stylesheet" type="text/css" href="global.css">
<link rel="stylesheet" href="highlight.css">
# ToDo MVC Application

We will demonstrate how to create a Scalejs application by creating a ToDo MVC app. Scalejs is better suited for creating large and scalable applications, but we will cover some basics with the ToDo MVC app such as:
* Composition of Modules
* View, View Models, and Bindings
* States and Routing


##Creating the Project

Creating a new Scalejs project is simple. Once you [Install Scalejs](./install.html), 
you can create a Scalejs project by simply selecting the template for a 
__Scalejs MVVM Application (CSS)__ from the project creation template.

For this tutorial we will use the CSS template. LESS will be covered in another tutorial. 

![Scalejs MVVM Application is listed under 'Visual C#' templates](./project1.png)

Every Scalejs Project has a similar file structure (as seen below) 
which is explained in more details in [Explanation and Overview](./overview.html)  for more details.  

![Files generated by project template](./project2.png)

Your application code, which we will be editting in this tutorial, is within the _app_ folder. 
This folder contains the [modules](./overview.html#modules) for your project. 
A module contains [bindings](./bindings.html), [viewmodels](./overview.html#viewmodels),
[styles](./overview.html#styles) and [views](./overview.html#views) for your project. 


To view and run the project, simply press __ctrl + f5__. Then open a browser with a [debugging console](./best.html#debug)(press F12 to open)
and navigate to http://localhost:8888 to see it in action!

!!UPDATE THIS PICTURE!!
![Hello World!](./helloworld.png)

_Scalejs MVVM Application template is a working Hello World! Sample. [See how Hello World works!](./hello.html)_

## Designing ToDoMVC Application

ToDo MVC application already has well defined [specification and design guidelines](./linktospec). 
Typically scalejs is used to create modular applications. Even though we do not need this for ToDoMVC
because it is so simple, we will show you to do it in a modular fashion.

A module is self-containing, independent, reusable component of your web application. Modules are loosely-coupled
meaning they do not depend on other modules. Modules contain views, viewmodels, styles, and bindings, which we will 
go over in more detail as we create the app.

Typically scalejs apps consist of a _main_ module will be responsible for the [layout](./overview.html#layout)
and other functional modules. An example of a functional module is the _todo_ module because it will be responsible 
for functional aspect of the application.

![ToDo App consists of two modules: main and todo](./todo.png)

You can take a look at our other [samples](./samples.html) to see what a more complex app might look like.

## Main Module

The main module will consist of a [view](./overview.html#views), [viewmodel](./overview.html#viewmodel), 
[bindings](./overview.html#bindings) and [styles](./overview.html#styles).

The __view__ defines templates.

The __viewmodel__ performs logical tasks, and exposes properties to the view.

The __bindings__ define what is bound to an element with a certain data class.

The __styles__ contain the .css files which are needed for the module

 
A Scalejs project generates modules which already include the view, viewmodel, bindings and styles.

### Main View

The _main_ module in our app we define the layout, so our view will mostly be a placeholder for other
templates to render themselves inside of it. The _view_ is an html file in the __views__ folder.

A _template_ is a parentless div in an html file within your _views_ folder that has an id with the postfix '_template'.
We only need to define one template for _main_. 

__main/views/main.html__
```xml
<div id="main_template">
    <section id="todoapp">
        <header id="header">
			<h1>todos</h1>
		<!-- we need to reference todo input here -->
		</header>
		<!-- we need to reference todo items here -->
	</section>
    <footer id="info">
		<p>Double-click to edit a todo</p>
	</footer>
</div>
```

Our layout references two templates from the _todo_ module: the input and the items. We split it up this way
so that our _main_ module also has control over the header "todos" and the todo module is soley responsible for
the funtionality of creating, showing, editting, and removing todos.

In order to render the templates from the todo module, there are a few things we need to do.
We use a [virtual binding](./mvvm.html#virtual) to tell the main template to render whatever template is given
to it in that place. We use [knockoutjs](http://knockoutjs.com/) to the binding, 
and here we are using the [render](./mvvm.html#render) binding. It is not much different than 
knockout's [template](./mvvm.html#template) binding but it takes an [observable](./mvvm.html#observable) so that
we can define the template which will be given to it at a later time. We could also change the template which is 
rendered here easily with this binding. 

The reason we use a virtual binding is because we do not want to create a new html element; we just want to take 
the contents of our template and render it here. We use observables because when you update an observable, it 
automatically updates the view, as well.

__main/views/main.html__
```xml
<div id="main_template">
    <section id="todoapp">
        <header id="header">
            <h1>todos</h1>
            <!-- ko render:todoInput-->
            <!-- /ko -->
        </header>
        <!-- ko render:todoItems -->
        <!-- /ko -->
    </section>
    <footer id="info">
        <p>Double-click to edit a todo</p>
    </footer>
</div>
```

We have created the view, however, if you were to refresh your browser, you would see the following error:

![It doesn't work :(](./error1.png)

We can fix this problem in the viewmodel.


### Main ViewModelc

Since we have referenced `todoInput` and `todoItems`, we have to define them in the [viewmodel](./overview.html#viewmodels)

## Creating the todo Module

To make a module is extremely easy with scalejs. 
__Right-click__ on the __app__ folder and select __Add > New Item.__
From the Add New Item window, search for _scalejs_ and select the 
__Scalejs MVVM Module (CSS)__. Name this module _todo_ and click __Add__.

![Creating a new Module](./module1.png)

Once we create a module we need to  add a reference to it in the __app.js__ file. 

```javascript
require([
    'scalejs!application/main,todo'
], function (
    application
) {
    'use strict';

    application.run();
});
```

## Creating the Views

The next step in this process is to create the [views](./overview.html#views).
In order to create the view, we need to section off the template we were given into two parts: main and todo. 
The views are html files which contain templates for the view and they are in the __views__ folder for each module.

For our main view, we need to do two things: add the html pertinent to the main module 
AND reference the todo module within this html. All html within the _todo_ module belongs in the views folder 
for the _todo_ module so it must be separated from the rest of the html.
 
This is what we get for the __main_template__ after extracting the html from the template we were given, 
and removing the html for the todo module.

```xml
<div id="main_template">
    <section id="todoapp">
        <header id="header">
			<h1>todos</h1>
		<!-- we need to reference todo input here -->
		</header>
		<!-- we need to reference todo items here -->
	</section>
    <footer id="info">
		<p>Double-click to edit a todo</p>
	</footer>
</div>
```

A _template_ is a parentless div in an html file within your _views_ folder that has an id with the postfix '_template'

Now let’s also make the templates for the todo module.

```xml
<div id="todo_items_template">
    <section id="main">
		<input id="toggle-all" type="checkbox">
		<label for="toggle-all">Mark all as complete</label>
		<ul id="todo-list">
			<!-- These are here just to show the structure of the list items -->
			<!-- List items should get the class `editing` when editing and `completed` when marked as completed -->
			<li class="completed">
				<div class="view">
					<input class="toggle" type="checkbox" checked>
					<label>Create a TodoMVC template</label>
					<button class="destroy"></button>
				</div>
				<input class="edit" value="Create a TodoMVC template">
			</li>
			<li>
				<div class="view">
					<input class="toggle" type="checkbox">
					<label>Rule the web</label>
					<button class="destroy"></button>
				</div>
				<input class="edit" value="Rule the web">
			</li>
		</ul>
	</section>
	<!-- This footer should hidden by default and shown when there are todos -->
	<footer id="footer">
		<!-- This should be `0 items left` by default -->
		<span id="todo-count"><strong>1</strong> item left</span>
		<!-- Remove this if you don't implement routing -->
		<ul id="filters">
			<li>
				<a class="selected" href="#/">All</a>
			</li>
			<li>
				<a href="#/active">Active</a>
			</li>
			<li>
				<a href="#/completed">Completed</a>
			</li>
		</ul>
		<!-- Hidden if no completed items are left -->
		<button id="clear-completed">Clear completed (1)</button>
	</footer>
</div>

<div id="todo_input_template">
    <input id="new-todo" placeholder="What needs to be done?" autofocus>
</div>
```

## Rendering Views

Next we need to compose these modules so that _todo_ module appears within the _main_ module.  
There are a few things we need to do. First of all, we need to make sure _todo_ doesn't try to render itself 
in the same place as the main module. The main module puts itself into the root, so we can remove that 
line of code from the __todoModule.js__ file

```javascript
/*global define */
define([
    'sandbox!todo',
    'app/todo/viewmodels/todoViewModel',
    'bindings!todo',
    'views!todo',
    'styles!todo'
], function (
    sandbox,
    todoViewModel
) {
    'use strict';

    return function todoModule() {
        var // imports
            //root = sandbox.mvvm.root,
            //template = sandbox.mvvm.template,
            registerStates = sandbox.state.registerStates,
            state = sandbox.state.builder.state,
            onEntry = sandbox.state.builder.onEntry,
            // vars
            todo = todoViewModel(sandbox);

        // Register application state for the module.
        registerStates('app',
            state('todo',
                onEntry(function () {
                    // Render viewModel using 'main_template' template 
                    // (defined in main.html) and show it in the `root` region.
                    todo.text('Hello World from todo!');
                    //root(template('todo_template', todo));
                })));
    };
});
```
Now that we've done this, we can instruct the main module to _render_ the templates for the todo module.

```xml
<div id="main_template">
    <section id="todoapp">
        <header id="header">
            <h1>todos</h1>
            <!-- ko render:todoInput-->
            <!-- /ko -->
        </header>
        <!-- ko render:todoItems -->
        <!-- /ko -->
    </section>
    <footer id="info">
        <p>Double-click to edit a todo</p>
    </footer>
</div>
```

We just added a [virtual binding](./mvvm.html#virtual) to our template. We use [knockoutjs](http://knockoutjs.com/) 
to provide binding, and here we are using the [render](./mvvm.html#render) binding. It is not much different than 
knockout's [template](./mvvm.html#template) binding but it works with observables. The reason we use a virtual 
binding is because we do not want to create a new html element; we just want to take the contents of our template 
and render it here.

We need to define _todoItems_ and _todoInput_ within __mainViewModel.js__ in order for this to work.

```javascript
/*global define */
define([
    'sandbox!main'
], function (
    sandbox
) {
    'use strict';

    return function () {
        var // imports
            observable = sandbox.mvvm.observable,
            // properties
            todoItems = observable(),
            todoInput = observable();

        return {
            todoItems: todoItems,
            todoInput: todoInput
        };
    };
});
```
We now have defined todo for main. But how do we actually make it so that todo renders itself here? 
Modules must be agnostic to other modules, so what we will do is assign this observable to a property 
on the [statechart](./overview.html#statechart). 

```javascript
/*global define */
define([
    'sandbox!main',
    'app/main/viewmodels/mainViewModel',
    'views!main',
    'bindings!main',
    'styles!main'
], function (
    sandbox,
    mainViewModel
) {
    'use strict';

    return function main() {
        var // imports
            root = sandbox.mvvm.root,
            template = sandbox.mvvm.template,
            registerStates = sandbox.state.registerStates,
            state = sandbox.state.builder.state,
            onEntry = sandbox.state.builder.onEntry,
            // vars
            mainVM = mainViewModel();

        // Register application state for the module.
        registerStates('root',
            state('app',
                state('main',
                    onEntry(function () {
                        // create state properties for rendering todo module templates
                        this.todoItems = mainVM.todoItems;
                        this.todoInput = mainVM.todoInput;
                        // Render viewModel using 'main_template' template 
                        // (defined in main.html) and show it in the `root` region.
                        root(template('main_template', mainVM));
                    }))));
    };
});
```

The reason we have statechart is to manage state and also to allow the creation and use of shared state. 
Modules should not really be concerned about each other. When we create
the _todoItems_ and _todoInput_ properties, we assign them to an empty observable. 
This observable can now be accessed and updated by another module, but main doesn't know anything about this 
other module – preserving the pattern of “loosely coupled” modules.

Now we also must tell _todoItems_ and _todoInput_ what to do. We do this in the statechart for todo. 
In __todoModule.js__, you should assign what we were previously putting in the root into this property.

```javascript
/*global define */
define([
    'sandbox!todo',
    'app/todo/viewmodels/todoViewModel',
    'bindings!todo',
    'views!todo',
    'styles!todo'
], function (
    sandbox,
    todoViewModel
) {
    'use strict';

    return function todoModule() {
        var // imports
            template = sandbox.mvvm.template,
            registerStates = sandbox.state.registerStates,
            state = sandbox.state.builder.state,
            onEntry = sandbox.state.builder.onEntry,
            // vars
            todo = todoViewModel(sandbox);

        // Register application state for the module.
        registerStates('app',
            state('todo',
                onEntry(function () {
                    // pass the template bindings to the appropriate property
                    this.todoItems(template('todo_items_template', todo));
                    this.todoInput(template('todo_input_template', todo));
                })));
    };
});
```

_Note: other unnessesary lines of code have been removed._

Now we can also observe we had made a mistake with our [statechart](./statechart.html). 
You might not be comfortable with statecharts just yet but take our word – not only is it easy to implement, 
it is also easy to understand and debug. It allows the control flow of your app to be managed properly. 
What we are currently doing here is adding a new child state to the _app_ state. But we are already doing so in main.
This will create the following statechart:

__!!PLACE STATECHART PICTURE HERE!!__

The way statechart works is that when a state which contains child states is entered, it always enters the first child state which is defined. 
But todo isn't really a child state of _app_. It is logically a child state of main, since you can never be in either 
main or todo. You must be in _main_ in order to be in _todo_.

So what do we do to resolve this? We must define the parent state of _todo_ to be _main_ instead of _app_.

```javascript
 // Register application state for the module.
        registerStates('main',
            state('todo',
                onEntry(function () {
                    // pass the template bindings to the appropriate property
                    this.todoItems(template('todo_items_template', todo));
                    this.todoInput(template('todo_input_template', todo));
                })));
```

Now we have created the following statechart

__!!PLACE OTHER STATECHART PICTURE HERE!!__

The only thing that is missing is the styles. Normally we would split up styles based on how they were used by
the modules and place them into the  __styles__ folder. This allows us to keep clean
and modular code. For large applications we would use LESS, but since this app is so small CSS will sufice. However,
since we are using a premade template and stylesheet, I will simply copy and paste their stylesheet into the __main.css__ file.

Now we have created the layout of your app!! Press __ctrl+f5__ to build the project and run IISExpress. 
See it in action in your browser at http://localhost:8888

![ToDo layout rendered](./todo1.png)

Now we need to add the functionality which is discussed in the spec. Let's take it step by step.

## Hide 'todo' when there are no todos

The first thing we will implement is the ability to detect the number of todos. 
For this, we will use an __observableArray__ to store the items. If you are familiar with knockout.js 
this should be easy to do. In the __todoViewModel.js__ is where we will create this property. 
Also we must add a reference to observableArray from the 'mvvm' extension. 
_Note: if everything works correctly, you should have intellisense on the namespaces within the sandbox._

```javascript
/*global define */
define([
    'sandbox!todo'
], function (
    sandbox
) {
    'use strict';

    return function () {
        var observableArray = sandbox.mvvm.observableArray,
            //properties
            items = observableArray();

        return {
            items: items
        };
    };
});
```
Since we need to hide __#main__ if this array is empty, we can do this by defining a special data-class. 
To add a data-class to an element in your template is very simple and straightforward. 
We will add the data-class _todo-visible_ in the __todo\_items\_tempate__.

The reason we use data-class instead of data-bind is so that we can define the data-class in our bindings file,
which will allow us the reuse the same binding without having to rewrite it.

```xml
<section id="main" data-class="todo-visible">
...
<footer id="footer" data-class="todo-visible">
```

Now we can define the logic behind the _todo-visible_ class in the __todoBindings.js__ file

```javascript
/*global define */
/*jslint sloppy: true*/
define({
    'todo-visible': function () {
        return {
            visible: this.items().length > 0
        };
    }
});
```

After saving these files, refresh the browsers to observe the appropriate divs being hidden.

## Adding a new todo

For this functionality, we need to bind the input to a new observable. Let's call it _newItem_

```javascript
/*global define */
define([
    'sandbox!todo'
], function (
    sandbox
) {
    'use strict';

    return function () {
        var observable = sandbox.mvvm.observable,
            observableArray = sandbox.mvvm.observableArray,
            //properties
            items = observableArray(),
            newItem = observable();

        return {
            items: items,
            newItem: newItem
        };
    };
});
```

This must be added to the 'value' binding of the input box, so we will give the input a class called _todo-input_

```xml
<div id="todo_input_template">
    <input id="new-todo" data-class="todo-input" placeholder="What needs to be done?" autofocus>
</div>
```

As before, we must also add a definition for this class in __todoBindings.js__

```javascript
/*global define */
/*jslint sloppy: true*/
define({
    'todo-visible': function () {
        return {
            visible: this.items().length > 0
        };
    },
    'todo-input': function () {
        return {
            value: this.newItem,
            valueUpdate: 'afterkeydown'
        };
    }
});
```

Now we need to add the logic so that when one presses enter a new todo is added to the list. 
First lets create a function in __todoViewModel.js__ to do so. We will call it _addItem_.

```javascript
/*global define */
define([
    'sandbox!todo'
], function (
    sandbox
) {
    'use strict';

    return function () {
        var observable = sandbox.mvvm.observable,
            observableArray = sandbox.mvvm.observableArray,
            has = sandbox.object.has,
            //properties
            items = observableArray(),
            newItem = observable();

        function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                items.push(item.trim());
            }
            newItem("");
        }

        return {
            items: items,
            newItem: newItem,
            addItem: addItem
        };
    };
});
```

You can implement _addItem_ whichever way you please, but in ours we use the [has](./api.html#has) function so
be sure to include it from the sandbox.

The next step is making sure this function gets called when the user hits enter. We can do that by defining an
event handler in the __todo-input__ data-class we defined from before.

```javascript
/*global define */
/*jslint sloppy: true,unparam: true*/
define(function () {
    var ENTER_KEY = 13;
    return {
        'todo-visible': function () {
            return {
                visible: this.items().length > 0
            };
        },
        'todo-input': function () {
            var addItem = this.addItem;
            return {
                value: this.newItem,
                valueUpdate: 'afterkeydown',
                event: {
                    keyup: function (data, e) {
                        if (e.keyCode === ENTER_KEY) {
                            addItem();
                        }
                    }
                }
            };
        }
    };
});
```
In this example, since we defined a function for the event, we lost the context of the outer function so we 
cannot use _this_ to get our viewModel properties. This is why at the top of the data-class, we’ve defined a 
var with the same name as the function we want to use and assigned the function defined in “this” to the var.

We also converted our bindings object to a function which will return the bindings object, so that we can define
'global' vars (which are local to the function containing the bindings) so we can reuse constants like _ENTER\_KEY_
in our bindings. We will need it again for editting an item, so it's good to do this now.

The last step in this is to actually make sure that items appear in the list. 
Right now we’re not binding the list to anything – but the fix is very simple.

```xml
    <section id="main" data-class="todo-visible">
        <input id="toggle-all" type="checkbox">
        <label for="toggle-all">Mark all as complete</label>
        <ul id="todo-list" data-bind="foreach: items">
            <li class="completed">
                <div class="view">
                    <input class="toggle" type="checkbox" checked>
                    <label data-bind="text: $data"></label>
                    <button class="destroy"></button>
                </div>
                <input class="edit" value="Create a TodoMVC template">
            </li>
        </ul>
    </section>
```

What we have done here is that instead of using a data-class we just used a regular binding. 
_foreach_ is a knockout binding which will take the contents of the div and render it as a template for each
item within the array _foreach_ is bound to. You can learn more about it [here](http://knockoutjs.com/documentation/foreach-binding.html)

After saving these files, refresh the browsers to observe the ability to add items to the list.

Okay – but this isn't enough. We also need to do a little extra work when adding an element so that it shows 
the completed class only when it is completed. To do this, we need to make only 2 changes. 
Firstly, in __todoViewModel.js__ make the following change to the item when it is pushed to the items array.

```javascript
        function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                items.push({
                    title: item.trim(),
                    completed: observable(false)
                });
            }
            newItem("");
        }
```

In __todo\_items_template__ also edit the li element so it looks like this

```xml
	<li data-bind="css: { completed: completed }">
        <div class="view">
            <input class="toggle" type="checkbox" data-bind="checked: completed">
            <label data-bind="text: title"></label>
            <button class="destroy"></button>
        </div>
        <input class="edit" value="Create a TodoMVC template">
	</li>
```

What we have done here, actually, is make it so that the completed class is only added if the item's _completed_
property is true. At the same time, we are also able to toggle this class on and off when we check or uncheck 
the item because we have bound the checkbox input to the _checked_ binding. Since _completed_ is an observable, 
when we check the item, _completed_ becomes true, so the css completed is applied to the list item.

After saving these files, refresh the browsers to observe that checking/unchecking the checkbox applies the 
appropriate class to the list item.

![Now we can add items to the todo list](./todo2.png)

