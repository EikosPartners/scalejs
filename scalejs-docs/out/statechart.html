<!DOCTYPE html>
<html>
<head>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <link rel="stylesheet" href="style/metro-bootstrap.min.css" />
	  <link rel="stylesheet" href="style/metro-bootstrap-responsive.min.css" />
    <script src="style/jquery.min.js"></script>
	  <script src="style/jquery.ui.widget.js"></script>	
    <script src="style/metro.min.js"></script>
	  <link rel="stylesheet" href="highlight.css" />

	<meta name="generator" content="DocPad v6.60.4" />
	<link  rel="stylesheet" href="highlight.css" />
    
	<style>
    header {
      height: 45px;
    }
    #content {
      overflow-y: scroll;
	  padding-right: 20px;
	  margin-left: 20px;
    }
    #sidebar {
      display: block;
      float: left;
      width: 300px;
      overflow-y: scroll;
      margin-right:20px;
    }
    body {
      overflow-y: hidden;
     }
	.metro h1 {
		color: #9a1616 !important;
	}	
	.metro .sidebar>ul ul, .metro .sidebar>ul ul li a {
		background-color: #3d3d3d;
		border: 0px;
		color: #fff;
	}
  </style>
    
	<script>
	function adjustHeight() {
		//adjust the height of the content and sidebar
		$("#content").outerHeight(window.innerHeight -45);
		$("#sidebar").outerHeight(window.innerHeight -45);
	}

    $(document).ready(function() {
		var path = window.location.pathname.replace("/scalejs/scalejs-docs/out","");
		
		//make selected page active on sidebar
		$("a[href='." + path +"']").parent().addClass("active");

		adjustHeight();
		$(window).resize(adjustHeight);

		//create code highlighting
		$('pre').each(function() {
			$(this).html($(this).html().replace(/!!\*/g, "<i style='background-color:#FFFF99'>").replace(/\*\*!/g, "</i>"));
		});

		console.log(path);
		//expand grid if it is grid
		if(path === '/grid1.html' || path === '/grid2.html') $('#grid-dropdown').css("display","block");
    });

  </script>
</head>
<body class="metro">

  <header>
	  <nav class="navigation-bar dark fixed-top">
    <div class="navigation-bar-content">
        <a href="./" class="element"><span class="icon-home"></span> SCALEJS</a>
        <span class="element-divider"></span>

        <a class="element1 pull-menu" href="#"></a>

        <ul class="element-menu no-desktop">
            <li>
                <a class="dropdown-toggle" href="#"><span class="icon-layers"></span> Docs</a>
                <ul class="dropdown-menu dark" data-role="dropdown">
                    <li>
                        <a href="#" class="dropdown-toggle">Getting Started</a>
                        <ul class="dropdown-menu dark" data-role="dropdown">
                            <li><a href="./docs.html"><i class="icon-star-3"></i> Introduction</a></li>
                            <li><a href="./install.html"><i class="icon-download-2"></i> Install Scalejs</a></li>
                            <li><a href="./project.html"><i class="icon-new"></i> Create an Application Project</a></li>
                            <!--<li><a href="./build.html"><i class="icon-cloud"></i> Build and Deployment</a></li>
                            <li><a href="./test.html"><i class="icon-checkmark"></i> Testing</a></li>
                            <li><a href="./best.html"><i class="icon-thumbs-up"></i> Best Practices</a></li>-->
                        </ul>
                    </li>
                    <li>
                        <a href="#" class="dropdown-toggle">Overview</a>
                        <ul class="dropdown-menu dark" data-role="dropdown">
                            <li><a href="./template.html"><i class="icon-clipboard-2"></i> Project Template</a></li>
                            <li><a href="./architecture.html"><i class="icon-puzzle"></i> Architecture</a></li>
                            <li><a href="./mvvm.html"><i class="icon-tree-view"></i> Model-View-ViewModel</a></li>
                            <li><a href="./statechart.html"><i class="icon-tab"></i> Statechart</a></li>
                            <li><a href="./routing.html"><i class="icon-share"></i> Routing</a></li>
                            <li><a href="./composition.html"><i class="icon-screen"></i> UI Composition</a></li>
                            <li><a href="./gridlayout.html"><i class="icon-grid-view"></i> Grid Layout</a></li>
                            <!-- <li><a href="./styles.html"><i class="icon-droplet"></i> Styles</a></li>
                            <li><a href="./extensions.html"><i class="icon-wrench"></i> Extensions</a></li>
                            <li><a href="./api.html"><i class="icon-book"></i> API Documentation</a></li>-->
                        </ul>
                    </li>
                    <li>
                        <a href="#" class="dropdown-toggle">UI Components</a>
                        <ul class="dropdown-menu dark" data-role="dropdown">
                            <li>
                                <a class="dropdown-toggle" href=""><i class="icon-grid"></i> Grid</a>
                                <ul class="dropdown-menu" data-role="dropdown">
                                    <li><a href="./grid1.html">Introduction</a></li>
                                    <li><a href="./grid2.html">Filtering</a></li>
                                    <!--<li><a href="./grid3.html">Sorting</a></li>-->
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="#" class="dropdown-toggle">Tutorials</a>
                        <ul class="dropdown-menu dark" data-role="dropdown">
                            <li><a href="./todomvc.html">ToDoMVC</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li class="divider"></li>
            <li><a title="Visual Studio Gallery" href="http://visualstudiogallery.msdn.microsoft.com/2a3d0050-ccab-458f-8bfc-2f2aca73e631"><span class="icon-box-add"></span> Visual Studio</a></li>
            <li class="divider"></li>
            <li><a title="GitHub" href="https://github.com/lisovin/scalejs/tree/master"><span class="icon-github-3"></span> GitHub</a></li>
        </ul>

        <div class="no-tablet-portrait no-phone">
            <a href="./docs.html" class="element"><span class="icon-layers"></span> Docs</a>
            <span class="element-divider"></span>

            <a title="Visual Studio Gallery" href="http://visualstudiogallery.msdn.microsoft.com/2a3d0050-ccab-458f-8bfc-2f2aca73e631" class="element place-right"><span class="icon-box-add"></span> Visual Studio</a>
            <span class="element-divider place-right"></span>

            <a title="GitHub" href="https://github.com/lisovin/scalejs/tree/master" class="element place-right"><span class="icon-github-3"></span> GitHub</a>
            <span class="element-divider place-right"></span>
        </div>
    </div>
</nav>
  </header>
  
  <div id="container">
     
       <div id="sidebar" class="sidebar no-tablet-portrait no-phone">
		      <ul>
			      <li class="title">Getting Started</li>
				      <li><a href="./docs.html"><i class="icon-star-3"></i> Introduction</a></li>
				      <li><a href="./install.html"><i class="icon-download-2"></i> Install Scalejs</a></li>
				      <li><a href="./project.html"><i class="icon-new"></i> Create an Application Project</a></li>
                            <!--<li><a href="./build.html"><i class="icon-cloud"></i> Build and Deployment</a></li>
                            <li><a href="./test.html"><i class="icon-checkmark"></i> Testing</a></li>
                            <li><a href="./best.html"><i class="icon-thumbs-up"></i> Best Practices</a></li>-->
			      <li class="title">Overview</li>
                            <li><a href="./template.html"><i class="icon-clipboard-2"></i> Project Template</a></li>
                            <li><a href="./architecture.html"><i class="icon-puzzle"></i> Architecture</a></li>
                            <li><a href="./mvvm.html"><i class="icon-tree-view"></i> Model-View-ViewModel</a></li>
                            <li><a href="./statechart.html"><i class="icon-tab"></i> Statechart</a></li>
                            <li><a href="./routing.html"><i class="icon-share"></i> Routing</a></li>
                            <li><a href="./composition.html"><i class="icon-screen"></i> UI Composition</a></li>
                            <li><a href="./gridlayout.html"><i class="icon-grid-view"></i> Grid Layout</a></li>
                            <!--<li><a href="./styles.html"><i class="icon-droplet"></i> Styles</a></li>
                            <li><a href="./extensions.html"><i class="icon-wrench"></i> Extensions</a></li>
                            <li><a href="./api.html"><i class="icon-book"></i> API Documentation</a></li>-->
				  <li class="title">UI Components</li>
				            <li>
								<a class="dropdown-toggle" href=""><i class="icon-grid"></i> Grid</a>
								<ul id="grid-dropdown" class="dropdown-menu" data-role="dropdown">
									<li><a href="./grid1.html">Introduction</a></li>
									<li><a href="./grid2.html">Filtering</a></li>
									<!--<li><a href="./grid3.html">Sorting</a></li>-->
								</ul>
							</li>
			      <li class="title">Tutorials</li>
				      <li><a href="./todomvc.html">ToDoMVC</a></li>
		      </ul>
	      </div>

	    <div id="content">
		    <h1 id="statechart">Statechart</h1>
<hr>

<p>Every interface has certain states which determine what is currently displayed on the UI. 
Originally state was managed indirectly with the <a href="./reactive.html">reactive</a> pattern by publishing events and
notifying subscribers. For instance, when a user logs in, modules which needed to show
user-related information would need to respond to this event and change their view. At the same time,
the layout needed to respond to this change to hide/show modules as neccessary. </p>
<p>It was soon found that without the concept of &quot;state&quot; this process became cumbersome to maintain.
This is why the scalejs devs decided to incorporate <a href="http://www.w3.org/TR/scxml/">Harel Statecharts</a>
to manage state. The way Statecharts differ from typical state machines is that they allow
for more complex states which is suited for User Interface design. The main differences is that
it allows you to create hierarchical states and parallel states. This will be elaborated on further below.</p>
<p>The statechart is one of the most original aspects of scalejs. Of course, the statechart isn&#39;t
part of the scalejs core, but it is already included for your convience in the <a href="./project.html">project template</a>.
It can be found in the <strong>scalejs.statechart-scion</strong> extension. This extension adapts <a href="https://github.com/jbeard4/SCION">scion statecharts</a>
so that they can be defined using builder functions.</p>
<p><br></p>
<h2 id="statechart-builder">Statechart Builder</h2>
<p>The statechart is created using builder functions which allow you to define states, transitions, and other
statechart-related properties. These builder functions are defined in the <strong>state.builder</strong> namespace
and can be nested so that complex hierarchical structures can be created.  The statechart builder
runs and creates the statechart before your application starts. The statechart cannot be altered
after the app runs. Therefore, the statechart is a deterministic function that for any given input
has a predictable output. This makes creating states very easy, clean, and concise.</p>
<p><br></p>
<h2 id="registerstates">registerStates</h2>
<p>The first step in the statechart building process is registering states onto the application state. </p>
<h5 id="example-adding-the-main-state-to-app-state">Example: adding the &quot;main&quot; state to &quot;app&quot; state</h5>
<pre class="highlight"><code class="hljs javascript">    <span class="hljs-keyword">var</span> registerStates = sandbox.state.registerStates,
        state = sandbox.state.builder.state;

    <span class="hljs-comment">// Add the "main" state as a child to the application state</span>
    registerStates(<span class="hljs-string">"app"</span>, state(<span class="hljs-string">"main"</span>))
</code></pre>
<p><code>registerStates</code> takes at least one argument. It expects a <code>state()</code> builder to be passed into it.</p>
<p>Use this function when registering states from the module. Ensure loose coupling by having states add <em>themselves</em> to the &quot;app&quot; state.</p>
<p><br></p>
<h2 id="state">state</h2>
<p>The second argument to <code>registerStates</code> should be a <code>state()</code> builder. Create hierarchical
structures by defining states as children or siblings of other states.</p>
<h5 id="example-creating-a-hierarchical-statechart">Example: creating a hierarchical statechart</h5>
<pre class="highlight"><code class="hljs javascript">    <span class="hljs-keyword">var</span> registerStates = sandbox.state.registerStates,
         state = sandbox.state.builder.state;

    <span class="hljs-comment">// hierarchical structure with 3 levels</span>

    registerStates(<span class="hljs-string">"app"</span>,                <span class="hljs-comment">//app state will be parent state</span>
        state(<span class="hljs-string">"A"</span>,                                <span class="hljs-comment">// State A - First Level State with 2 children</span>
            state(<span class="hljs-string">"A.1"</span>),                                <span class="hljs-comment">//State A.1 &amp; A.2 - Second level sibling states</span>
            state(<span class="hljs-string">"A.2"</span>)),
        state(<span class="hljs-string">"B"</span>,                                <span class="hljs-comment">// State B - Another First Level State with 3 children and 1 grandchild</span>
            state(<span class="hljs-string">"B.1"</span>),                            <span class="hljs-comment">// State B.1, B.2, &amp; B.3 - Second level sibling states</span>
            state(<span class="hljs-string">"B.2"</span>),
            state(<span class="hljs-string">"B.3"</span>,                            <span class="hljs-comment">// State B.3 - 2 children states</span>
                state(<span class="hljs-string">"B.3.a"</span>),                        <span class="hljs-comment">//State B.3.1 &amp; State B.3.b - Third level sibling states</span>
                state(<span class="hljs-string">"B.3.b"</span>s))),
        state(<span class="hljs-string">"c"</span>));
</code></pre>
<p>You can create infinitely long statecharts, or create and organized structure with abstracted code</p>
<h5 id="example-abstracting-states-into-functions">Example: abstracting states into functions</h5>
<pre class="highlight"><code class="hljs javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stateA</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">return</span> state(<span class="hljs-string">"A"</span>,                                
            state(<span class="hljs-string">"A.1"</span>), state(<span class="hljs-string">"A.2"</span>));
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stateB</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">return</span> state(<span class="hljs-string">"B"</span>,                                
            state(<span class="hljs-string">"B.1"</span>),                            
            state(<span class="hljs-string">"B.2"</span>),
            state(<span class="hljs-string">"B.3"</span>,                            
                state(<span class="hljs-string">"B.3.a"</span>),                        
                state(<span class="hljs-string">"B.3.b"</span>))));
    }


    registerStates(<span class="hljs-string">"app"</span>,            
        stateA(), stateB(), state(<span class="hljs-string">"c"</span>);
</code></pre>
<p>Statecharts are prebuilt before the application runs. This allows modules to set up their states
in advance. Assume modules to be loaded dynamically because they are independent of one another.
This means you cannot have control over the <em>order</em> of the states being registered parent state.</p>
<h5 id="example-registering-states-from-2-different-modules-on-the-same-parent-state">Example: registering states from 2 different modules on the same parent state</h5>
<p><em>mainModule.js</em></p>
<pre class="highlight"><code class="hljs javascript">    registerStates(<span class="hljs-string">"app"</span>, <span class="hljs-string">"main"</span>);
</code></pre>
<p><em>genericModule.js</em></p>
<pre class="highlight"><code class="hljs javascript">    registerStates(<span class="hljs-string">"app"</span>, <span class="hljs-string">"generic"</span>);
</code></pre>
<p>In these snippits of code note that:</p>
<ul>
<li>They are evaluated in the module js file, which means they are added to the state when the module is created (before the app runs)</li>
<li>Modules which are independent of other modules can load asynchonously </li>
<li>Therefore when the application starts it will be either enter the &quot;main&quot; state or the &quot;generic&quot; state</li>
<li>This is because when a normal state defines children, these children are mutually exclusive and the first child state is automatically entered.</li>
<li>The state of the application is always a &quot;leaf&quot; state - it must have NO children</li>
</ul>
<p>In order to preserve order, you can define a state in a module which is a child of a state created in another module</p>
<h5 id="example-registering-a-state-from-one-module-as-a-child-to-the-state-of-another-module">Example: registering a state from one module as a child to the state of another module</h5>
<p><em>mainModule.js</em></p>
<pre class="highlight"><code class="hljs javascript">    registerStates(<span class="hljs-string">"app"</span>, <span class="hljs-string">"main"</span>);
</code></pre>
<p><em>genericModule.js</em></p>
<pre class="highlight"><code class="hljs javascript">    registerStates(<span class="hljs-string">"main"</span>, <span class="hljs-string">"generic"</span>);
</code></pre>
<p>This brings us to some statechart &quot;rules&quot;</p>
<ul>
<li>The application state must always be a <strong>childless state</strong></li>
<li>The application state always a parent state before it enters the child state</li>
<li>The application always exits a child state before it exits the parent state</li>
<li>The statechart is built before the application runs and <em>after</em> all modules have been created.</li>
</ul>
<p>This means it doesn&#39;t matter if the &quot;genericModule&quot; is created before the &quot;mainModule&quot; - the statechart is smart enough to know to build the statechart in the correct order!</p>
<p>But making a state a child state is not the only way to preserve order. In fact, it is far from the recommended way.
Let&#39;s postulate that there is no &quot;mainModule&quot; at all. This would cause the statechart build step to fail, because there is no &quot;main&quot; state defined but
&quot;generic&quot; is defined as a child for the &quot;main&quot; state. In order to ensure that order and loose coupling are enforced, it is best to have
a base state and have modules define themselves on that state. That way you do not have a huge chain of depencies with your modules.</p>
<p>This leads to the problem we saw in the previous code snippet in which the first state which is defined is the state which is entered.
In order to create a predictable flow and order of your statechart, you can use <em>events</em> and <em>transitions</em> to hop from state to state!</p>
<p><br></p>
<h2 id="onentry">onEntry</h2>
<p>There has so far been one major thing missing from our discussion of states. We&#39;ve told you
how to create states and nest states, but we haven&#39;t told you what you can <em>do</em> with states.</p>
<p>When a state is entered, typically the following can be done:</p>
<ul>
<li>Set application state properties to be accesible to all other states</li>
<li>Update the module&#39;s ViewModel so that it shows the appropriate View for the state</li>
</ul>
<p>This can be done by calling <code>onEntry</code> and passing a function.</p>
<h5 id="example-defing-an-onentry-transition">Example: defing an onEntry transition</h5>
<pre class="highlight"><code class="hljs javascript">    <span class="hljs-keyword">var</span> registerStates = sandbox.state.registerStates,
         state = sandbox.state.builder.state,
         onEntry = sandbox.state.builder.onEntry;

    registerStates(<span class="hljs-string">"app"</span>,
        state(<span class="hljs-string">"main"</span>,
            onEntry(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
                <span class="hljs-comment">// do stuff here!</span>
                sandbox.debug.log(<span class="hljs-string">"onEntry of main state called"</span>);
            })));
</code></pre>
<p>When you enter a state, you can set a property of your viewModel to be a property of your state.</p>
<h5 id="example-creating-a-property-on-the-statechart">Example: creating a property on the statechart</h5>
<pre class="highlight"><code class="hljs javascript">    <span class="hljs-keyword">var</span>  <span class="hljs-comment">// imports</span>
         registerStates = sandbox.state.registerStates,
         state = sandbox.state.builder.state,
         onEntry = sandbox.state.builder.onEntry,
         <span class="hljs-comment">// viewModel</span>
         viewModel = mainViewModel();

    registerStates(<span class="hljs-string">"app"</span>,
        state(<span class="hljs-string">"main"</span>,
            onEntry(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
                <span class="hljs-comment">// you can set state properties by adding them to "this"</span>

                <span class="hljs-keyword">this</span>.region = viewModel.region;
            })));
</code></pre>
<p>In this example, the mainViewModel defines a &quot;region&quot; property. This is a property of the state
because it is being used to define a region in the template which can be used to render templates
from other modules. In order for other modules to have access to this property, it must be made
part of the state. </p>
<p>We go more in depth about regions and how to use them in the statechart in the <a href=".layout.html">layout</a> section.</p>
<p>In the following example, you can see how easy it is to update the viewModel from the statechart.
This gives you control over what is displayed in the view when in certain states.</p>
<h5 id="example-updating-a-viewmodel-property-from-the-state">Example: updating a viewModel property from the state</h5>
<pre class="highlight"><code class="hljs javascript">    <span class="hljs-keyword">var</span>  <span class="hljs-comment">// imports</span>
         registerStates = sandbox.state.registerStates,
         state = sandbox.state.builder.state,
         onEntry = sandbox.state.builder.onEntry,
         <span class="hljs-comment">// viewModel</span>
         viewModel = mainViewModel();

    registerStates(<span class="hljs-string">"app"</span>,
        state(<span class="hljs-string">"main"</span>,
            onEntry(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
                <span class="hljs-comment">// when entering a state, you can choose to update the viewModel to reflect that state</span>

                viewModel.entered(<span class="hljs-literal">true</span>);
            })));
</code></pre>
<p>You can also modify state properties when the state is entered as well.
Because of this, the properties of your viewModels and statechart can be strictly controlled by what you do when states are entered.</p>
<p><br></p>
<h2 id="onexit">onExit</h2>
<p>onExit is pretty much the same as onEntry, except it runs after a state is exitted.
You can use this to remove any changes to the statechart and viewModel that were done in onEntry,
so that states only need to worry about how to display themselves!</p>
<p>For example, if you want to hide the mainModule when you enter/exit the main application, you might do something like this:</p>
<h5 id="example-using-onexit-to-undo-changes-made-by-onentry">Example: using onExit to undo changes made by onEntry</h5>
<pre class="highlight"><code class="hljs javascript">    <span class="hljs-keyword">var</span>  <span class="hljs-comment">// imports</span>
         registerStates = sandbox.state.registerStates,
         state = sandbox.state.builder.state,
         onEntry = sandbox.state.builder.onEntry,
         onExit = sandbox.state.builder.onExit,
         <span class="hljs-comment">// viewModel</span>
         viewModel = mainViewModel();

    registerStates(<span class="hljs-string">"app"</span>,
        state(<span class="hljs-string">"main"</span>,
            onEntry(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
                <span class="hljs-comment">// when entering a state, you can choose to update the viewModel to reflect that state</span>
                viewModel.entered(<span class="hljs-literal">true</span>);
            }),
            onExit(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
                <span class="hljs-comment">// when exiting a state, you can update the viewModel so it no londer indicates that it is in this state</span>
                viewModel.entered(<span class="hljs-literal">false</span>);
            }));
</code></pre>
<p>For this to toggle the visibility on the main module, you can bind the <code>entered</code> property to a visible binding.
<em>*Note: more programming is required to actually render the templates for the main module, which is elaborated on in <a href="./layout.html">layout</a></em></p>
<p>[To be continued: Using arguments passed on onEntry and onExit)</p>
<p><br></p>
<h2 id="on">on</h2>
<p>The next step in building the statechart is telling the statechart how to transition from state to state.
To specify a transition on a state, you can pass the <code>on</code> function to a state. <code>on</code> takes up to 3 parameters.
There are two required arguments: the first argument is a string which specified the event hook (created with <code>raise</code>).
The second (optional) argument can be a function which allows this transition to be conditional (e.g. if the function returns
true then the transition runs, if not it does not run). The last argument is a <code>goto</code> builder which
specifies the destination state. </p>
<h5 id="example-defining-a-transition">Example: defining a transition</h5>
<pre class="highlight"><code class="hljs javascript">    <span class="hljs-keyword">var</span>  <span class="hljs-comment">// imports</span>
         registerStates = sandbox.state.registerStates,
         state = sandbox.state.builder.state,
         on = sandbox.state.builder.on,
         goto = sandbox.state.builder.goto;

    registerStates(<span class="hljs-string">"app"</span>,
        state(<span class="hljs-string">"main"</span>,
            state(<span class="hljs-string">"main.loading"</span>),
            state(<span class="hljs-string">"main.loaded"</span>),
            on(<span class="hljs-string">"main.loaded.completed"</span>, goto(<span class="hljs-string">"main.loaded"</span>))));
</code></pre>
<p>When <code>on</code> is defined on a state, that event is only triggered if the application is in the state.
This allows you to ensure transitions are run when you are in the correct state. If the application
is not in the <code>main</code> state and <code>main.loaded.completed</code> event is raised, the transition will
not occur. This solves many application development headaches by simplifying the logic needed
to determine the flow of the application.</p>
<p>Transions can also be conditional.</p>
<h5 id="example-defining-a-transition">Example: defining a transition</h5>
<pre class="highlight"><code class="hljs javascript">    <span class="hljs-keyword">var</span>  <span class="hljs-comment">// imports</span>
         registerStates = sandbox.state.registerStates,
         state = sandbox.state.builder.state,
         on = sandbox.state.builder.on,
         goto = sandbox.state.builder.goto;

    registerStates(<span class="hljs-string">"app"</span>,
        state(<span class="hljs-string">"main"</span>,
            state(<span class="hljs-string">"main.loading"</span>),
            state(<span class="hljs-string">"main.loaded"</span>),
            state(<span class="hljs-string">"main.error"</span>),
            on(<span class="hljs-string">"main.loaded.completed"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> {</span>
                <span class="hljs-keyword">return</span> data.success;
            }, goto(<span class="hljs-string">"main.loaded"</span>)),
            on(<span class="hljs-string">"main.loaded.completed"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> {</span>
                <span class="hljs-keyword">return</span> !data.success;
            }, goto(<span class="hljs-string">"main.error"</span>))));
</code></pre>
<p>In this example, when <code>raise</code> is called it is also passed some data. This data
is provided to the transition so that it can be processed. For example,
in the &quot;loading&quot; state, the data may load but it might be successful or unsuccessful.
Passing additional data when the <code>main.loaded.completed</code> event is raised allows
you to react to the data being passed and prevent the evaluation of the transition if neccesary by
having it return a falsey value, or continue the evaluation of the transition by returning a true value.</p>
<p>Using events and transitions allow you to jump from state to state. In order to activate these transitions,
your application needs to raise events so that the statechart can respond.</p>
<p><br></p>
<h2 id="raise">raise</h2>
<p><code>raise</code> is pretty straightforward: it creates an event that your statechart listens for. 
If a transition is defined for the event in the current state that it&#39;s in, then the transition runs.</p>
<h5 id="example-using-raise-to-create-an-event">Example: using raise to create an event</h5>
<pre class="highlight"><code class="hljs javascript">    <span class="hljs-keyword">var</span>  <span class="hljs-comment">// imports</span>
         registerStates = sandbox.state.registerStates,
         state = sandbox.state.builder.state,
         onEntry = sandboxstate.builder.onEntry,
         on = sandbox.state.builder.on,
         goto = sandbox.state.builder.goto
         raise = sandbox.state.raise,
         <span class="hljs-comment">// viewmodel</span>
         viewModel = mainViewModel();

    registerStates(<span class="hljs-string">"app"</span>,
        state(<span class="hljs-string">"main"</span>,
            state(<span class="hljs-string">"main.loading"</span>,
                onEntry(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
                    viewModel.load(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
                        raise(<span class="hljs-string">"main.loaded.completed"</span>)
                    });
                })),
            state(<span class="hljs-string">"main.loaded"</span>),
            on(<span class="hljs-string">"main.loaded.completed"</span>, goto(<span class="hljs-string">"main.loaded"</span>))));
</code></pre>
<p>In this example, when the <code>main.loading</code> state is entered, it calls a function
defined in the viewModel called <code>load</code>. It passes to <code>load</code> a callback
that will raise the <code>main.loaded.completed</code> after load completes. Since the application
enters the <code>main</code> state, the transition defined on this state is evaluated as it matches
the event. This will transition the application from the <code>main.loading</code> state to the <code>main.loaded</code>
state.</p>
<p><code>raise</code> can also be called with some additional data which can allow you to create conditional transitions.</p>
<h5 id="example-using-raise-to-create-an-event-with-additional-data">Example: using raise to create an event with additional data</h5>
<pre class="highlight"><code class="hljs javascript">    <span class="hljs-keyword">var</span>  <span class="hljs-comment">// imports</span>
         registerStates = sandbox.state.registerStates,
         state = sandbox.state.builder.state,
         onEntry = sandboxstate.builder.onEntry,
         on = sandbox.state.builder.on,
         goto = sandbox.state.builder.goto
         raise = sandbox.state.raise,
         <span class="hljs-comment">// viewmodel</span>
         viewModel = mainViewModel();

    registerStates(<span class="hljs-string">"app"</span>,
        state(<span class="hljs-string">"main"</span>,
            state(<span class="hljs-string">"main.loading"</span>,
                onEntry(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
                    viewModel.load(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(success)</span> {</span>
                        raise(<span class="hljs-string">"main.loaded.completed"</span>, { success: success })
                    });
                })),
            state(<span class="hljs-string">"main.loaded"</span>),            
            state(<span class="hljs-string">"main.error"</span>),
            on(<span class="hljs-string">"main.loaded.completed"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> {</span>
                <span class="hljs-keyword">return</span> data.success;
            }, goto(<span class="hljs-string">"main.loaded"</span>)),
            on(<span class="hljs-string">"main.loaded.completed"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> {</span>
                <span class="hljs-keyword">return</span> !data.success;
            }, goto(<span class="hljs-string">"main.error"</span>))));
</code></pre>
<p>In this example, the the viewModel fails to load, it can transition to the <code>main.error</code> state
as opposed to the <code>main.loaded</code> state.</p>
<p><br></p>
<h2 id="goto">goto</h2>
<p>So far you&#39;ve seen how to create transitions using <code>on</code>. One of the required parameters of <code>on</code>
is a <code>goto</code> builder. <code>goto</code> requires a state id. If the transition runs, the application
leaves the current state and enters the new state.</p>
<p><code>goto</code> is implemented in such a way that if you were to try to use it to transition to a child state,
it exits and re-enters the current state.</p>
<p><br></p>
<h2 id="gotointernally">gotoInternally</h2>
<p>Almost exactly the same as goto, except it can transition from a parent state to a child state without
first having to re-enter the state it is in. It transitions the app directly to the child state.</p>
<p>This is used almost as often as <code>goto</code> so knowing the difference is important.</p>
<p><br></p>
<h2 id="parallel">parallel</h2>
<p><code>parallel</code> is similar to <code>state</code> but instead of expecting mutually exclusive child states,
it allows all of its children states to run in parallel to eachother. </p>
<p>Parallel states can be very useful when implementing authentication. When a user logs in,
how does the application react? What visual aspects change? This can be managed by having two
parallel states defined on main like so:</p>
<h5 id="example-defining-parallel-states">Example: defining parallel states</h5>
<pre class="highlight"><code class="hljs javascript">    <span class="hljs-keyword">var</span> registerStates = sandbox.state.registerStates,
        parallel = sandbox.state.builder.parallel,
        state = sandbox.state.builder.state;

    registerStates(<span class="hljs-string">'root'</span>, parallel(<span class="hljs-string">'app'</span>,
        state(<span class="hljs-string">'authentication'</span>),
        state(<span class="hljs-string">'main'</span>)));
</code></pre>
<p>In this example, the app now has two parallel states: an authentication state and the main state which 
controls the UI/Layout. These states themselves can have mutually exclusive children:</p>
<h5 id="example-a-benefit-of-parallel-states-convienience">Example: a benefit of parallel states - convienience</h5>
<pre class="highlight"><code class="hljs javascript">    <span class="hljs-keyword">var</span> registerStates = sandbox.state.registerStates,
        parallel = sandbox.state.builder.parallel,
        state = sandbox.state.builder.state;

    registerStates(<span class="hljs-string">'root'</span>, parallel(<span class="hljs-string">'app'</span>,
        state(<span class="hljs-string">'authentication'</span>,
            state(<span class="hljs-string">'logged.in'</span>),
            state(<span class="hljs-string">'logged.out'</span>)),
        state(<span class="hljs-string">'layout'</span>,
            state(<span class="hljs-string">'dashboard'</span>),
            state(<span class="hljs-string">'main'</span>))));
</code></pre>
<p>This means your app is in both a child state of &quot;authentication&quot; and &quot;layout&quot; throughout its lifecycle.
You can easily go from logged in to logged out with minimal amount of code.</p>

	    </div>

  </div>
</div>
    
</body>
</html>