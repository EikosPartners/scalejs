---
title: "ToDo MVC"
isPage: true
---

#ToDoMVC App Tutorial

<hr>

We will demonstrate how to create a Scalejs application by creating a ToDo MVC app. Scalejs is better suited for creating large and scalable applications, but we will cover some basics with the ToDo MVC app such as:

* Creating and Rendering Modules
* View, View Models, and Bindings
* States and Routing

This tutorial is created using scalejs v0.3.5. 

__You can view and clone this application from [this repository](https://github.com/egucciar/todomvc/tree/scalejs/labs/architecture-examples/scalejs/ToDoMVC)__.
The commit history follows the major steps in this tutorial.

<br>

## 1. Create the Project

After you [Install Scalejs](./install.html), create a new scalejs project by selecting the template for a 
__Scalejs MVVM Application (CSS)__ from the project creation window.

![Scalejs MVVM Application is listed under 'Visual C#' templates](./project1.png)

_For this tutorial we will use the CSS template. LESS will be covered in another tutorial_

Every Scalejs Project has a similar file structure (as seen below) 
which is explained in in depth [here](./template.html). 
Your application code, which we will be editing in this tutorial, is within the _app_ folder. 
This folder contains the [modules](./architecture.html#modules) for your project. 
A module contains [bindings](./mvvm.html#bindings), [viewmodels](./mvvm.html#viewmodel),
[styles](./styles.html) and [views](./mvvm.html#view). 

![Files generated by project template](./project2.png)

To view and run the project, press __ctrl + f5__. Then open a browser with a [debugging console](./best.html#debug) (press F12 to open)
and navigate to http://localhost:8888 to see it in action!

![Hello World!](./helloworld.png)

__For further changes to the app to work, make sure to disable caching in your browser!__

### Designing ToDoMVC Application

The ToDo MVC application already has well defined [specification and design guidelines](https://github.com/tastejs/todomvc/blob/gh-pages/app-spec.md). 
Typically scalejs is used to create modular applications. Even though we do not need this for ToDoMVC
because it is so simple, we will show you to do it in a modular fashion.

A module is _self-contained, independent, and reusable_ component of your web application. Modules are loosely-coupled
meaning they do not depend on other modules. Modules contain views, viewmodels, styles, and bindings, which we will 
go over in more detail as we create the app.

Typically scalejs apps consist of a _main_ module and other functional modules. 
The main module is responsible for the overall application [layout](./layout.html), setting up [routing](./routing.html), and 
setting up the application [statechart](./statechart.html). It usually does not contain any business specific functionality. 
Functional modules are responsible for implementing business functionality.
An example of a functional module is the _todo_ module.

In our ToDoMVC app, there are 2 modules: _main_ and _todo_. Notice how _main_ is the outer module, and consists
of the header and background, whereas the _todo_ module shows the todos and lets you interact with them.

![ToDo App consists of two modules: main and todo](./todo.png)

### MVVM Concepts

Before we cover the rest of the tutorial, we will briefly discuss what MVVM is and how it is used in scalejs. 
MVVM stands for __Model-View-ViewModel__, which is an application design pattern used to enforce separation of concerns.

In our scalejs app, each module has its _own_ models, views and viewmodels..
A module consists of a [view](./mvvm.html#views), [viewmodel](./mvvm.html#viewmodel), 
[bindings](./mvvm.html#bindings) and [styles](./mvvm.html#styles). Therefore, along with the javascript file
which will initialize a module, there are 4 additional folders within a module which contain the javascript files for the ViewModel
and the HTML and CSS files for the view. We also can define our bindings between the ViewModel and View in a separate file.

The __view__ defines templates for your modules. It is responsible for the visual representation of your module and is written in html.

The __viewmodel__ performs logical tasks, and exposes properties to the view. 
These properties can be bound to the view in such a way that when a change is made in the viewmodel, 
it will automatically update the view. Also, the reverse would also work;
 if you made a change in the view (e.g. inputting a value into a textbox), it will update the corrosponding
viewmodel property. 

The __bindings__ define what is bound to an element with a certain data class. You can bind properties of the view model directly to 
HTML elements using `data-bind`, but for more complex bindings you can bind the element to a class name using `data-class`. 
This class must be defined in the bindings.

The __styles__ contain the .css files which are needed for the module.

A Scalejs project generates modules which already include the view, viewmodel, bindings and styles.

<br>

## 2. Create the Main Module

The main module serves as a shell of our application. 
In this module, we define the layout and styles, but we do not define
the functional aspects of the application. 
Rather, we specify __named regions__ in the html
which are merely be placeholders for content. Views from other modules can
appear in these placeholders. 
It can also define certain top-level UI elements, such as the background, main menu, or toolbar. 

It defines the overall appearance of the application. 
It might define styles and borders that are present and visible in the shell layout itself, 
and it might also define styles, templates, and themes that will be applied to the views that 
are plugged into placeholders.

### Main View

The _main_ view defines the html for the layout and is located in in the __views__ folder.

A __template__ is a parentless div in an html file within your _views_ folder that has an id with the postfix `_template`.
We only need to define one template for _main_ which specifies the layout.

<sub>__app/main/views/main.html__</sub>
```xml
<div id="main_template">
    <section id="todoapp">
        <header id="header">
			<h1>todos</h1>
		<!-- we need to reference todo input here -->
		</header>
		<!-- we need to reference todo items here -->
	</section>
    <footer id="info">
		<p>Double-click to edit a todo</p>
	</footer>
</div>
```

Our layout defines two regions (items and input) that can become filled by
views within the _todo_ module. We split it up this way
so that our _main_ module also has control over the header "todos" and the _todo_ module is solely responsible for
the funtionality of creating, showing, editing, and removing todos.

__In order to allow the todo module to render the views, the first thing we need to do is __bind the view to the viewmodel__.
We use a [knockoutjs](http://knockoutjs.com/) [virtual binding](./mvvm.html#virtual) to create the regions in the layout. 
The binding which we are using is [render](./mvvm.html#render). 

The reason we use a virtual binding is because we do not want to create a new html element; we just want to take 
the contents of the view and render them where virtual binding is declared. Had we used regular bindings,
which we will see in the next section, a new html element would need to be created as a wrapper for the
bound content. 

<sub>__app/main/views/main.html__</sub>
```xml
<div id="main_template">
    <section id="todoapp">
        <header id="header">
            <h1>todos</h1>
            !!*<!-- ko render:todoInput-->
            <!-- /ko -->**!
        </header>
        !!*<!-- ko render:todoItems -->
        <!-- /ko -->**!
    </section>
    <footer id="info">
        <p>Double-click to edit a todo</p>
    </footer>
</div>
```

We have created the view, however, if you were to run the app, you would see an error.

>Save the file, refresh the browser, and open the debugging console to see the following

![It doesn't work :(](./error1.png)

We can fix this problem in the viewmodel.


### Main ViewModel

For a brief moment, we will diverge from our tutorial in order to explain some important concepts which
will be used repeatedly within our JavaScript files.

The [ViewModel](./mvvm.html#viewmodel) is a [requirejs](http://requirejs.org/) module. Requirejs gives scalejs the ability to load modules with
the necessary dependencies while also keeping the global namespace clean since everything defined within the module
is scoped to the function passed into `define`. Optionally, you can define an array of arguments to be passed
into the function which is called, and these can be references to other requirejs modules or scalejs components,
such as the sandbox (which can be seen in the below example.) The mainModule.js file and bindings file are also
requirejs modules. _Every JavaScript file within the app will most likely be a requirejs module._

Another thing in our modules, and more specifically ViewModels, which is of importance is the use of observables. 
Using scalejs requires an understanding
of the MVVM functionality which is provided by [knockoutjs](http://knockoutjs.com/) so it is a good idea to get familiar
with knockout bindings. What you need to care about now is that observables provide automatic UI updating when they
are bound to an HTML element. This means that a change to this property will automatically refresh the corresponding
UI component, without needing to explictly update the UI whenever it needs to be changed.

In order to use `observable` in our code, we import it from the `sandbox` by 
setting it to a var at the top of our module. The `sandbox` is where extensions can
place themselves and expose functions for modules to use. The `sandbox` allows  modules
to access these extensions in a sandboxed manner, so no module has access to another
module's sandbox.  `observable` is included in the `mvvm` extension. You can learn
more about the [sandbox](./architecture.html#sandbox) and the [mvvm extension](./mvvm.html)
in our docs. 

![Magicall](./intellisense1.png)

One of the great benefits to scalejs is that we have [intellisense](./best.html#intellisense)
for all of extensions and functions in the sandbox. Keep a look out for what happens as 
you add functions from the sandbox to your app, and feel free to take a peek at what is 
exposed on the sandbox with the handy dandy intellisense.

Now back to the tutorial.

Since we have referenced `todoInput` and `todoItems` in the view, we have to define them in the viewmodel. 
Making the following change will fix the issues we just saw after altering the view.

<sub>__app/main/viewmodels/mainViewModel.js__</sub>
```javascript
/*global define */
define([
    'sandbox!main'
], function (
    sandbox
) {
    'use strict';

    return function () {
        var // imports
            observable = sandbox.mvvm.observable,
            // properties
            !!*todoItems = observable(),
            todoInput = observable();**!

        return {
            !!*todoItems: todoItems,
            todoInput: todoInput**!
        };
    };
});
```


The view is bound to `todoItems` and `todoInput` which is why they must be __returned from the viewmodel__.
If we did not return them here, the view would not be able to access it - they would be _private_ variables. 
It is best practice to only return variables that are needed in another file within the module (e.g. _public_ variables). 
In this case, we need it in the view. We could also access these from
the module or another viewmodel. As you can now see, exposing these properties in the view resolved the issues from earlier.

![Main ViewModel is working](./mainvm1.png)

### Main Statechart

Render can be bound to a template and corresponding data. We want to render content from the _todo_ module, 
but in order for the _todo_ module to update these observables, we need to expose it in the [statechart](./statechart.html). 

The statechart defines the states and flow of your application. The statechart consists of two things: states and transitions. When we transition to a state, we set up the
state within the `onEntry` transition. We also can listen for events (which are called with `raise`) and
transition to the appropriate state based upon that. A benefit of the statechart is that states can be hierarchical and can also run in parallel to eachother. 
For example, our router is a parallel state and we will discuss [routing](./routing.html) later on.
The statechart is better understood in practice, but you can familiarize yourself with the statechart from
the [statechart documentation](./statechart.html)

In order to preserve loose-coupling, the statechart must allow modules to be agnostic to each other, 
so that the _main_ module does not need to know any details about the _todo_ module or vice versa. 
The modules will, however, be concerned with the statechart as it defines the flow of the application. 

In this situation, we would like to define `todoItems` and `todoInput` on the statechart so that the _todo_
module can access them. The statechart context is shared between all states in all the modules. 
If used properly, this what allows modules to affect one another while still being loosely coupled.

Adding properties to the statechart is very simple; the context of the statechart is exposed via `this` 
within the functions of the statechart (i.e. `onEntry`). 

<sub>__app/main/mainModule.js__</sub>
```javascript
/*global define */
define([
    'sandbox!main',
    'app/main/viewmodels/mainViewModel',
    'views!main',
    'bindings!main',
    'styles!main'
], function (
    sandbox,
    mainViewModel
) {
    'use strict';

    return function main() {
        var // imports
            root = sandbox.mvvm.root,
            template = sandbox.mvvm.template,
            registerStates = sandbox.state.registerStates,
            state = sandbox.state.builder.state,
            onEntry = sandbox.state.builder.onEntry,
            // vars
            !!*mainVM = mainViewModel();**!

        // Register application state for the module.
        registerStates('root',
            state('app',
                state('main',
                    onEntry(function () {
                        !!*// create state properties for rendering todo module templates
                        this.todoItems = mainVM.todoItems;
                        this.todoInput = mainVM.todoInput;**!
                        // Render viewModel using 'main_template' template 
                        // (defined in main.html) and show it in the `root` region.
                        !!*root(template('main_template', mainVM));**!
                    }))));
    };
});
```
_Note: We renamed_ `viewModel` _to_ `mainVM` _to avoid ambiguity_

Recall that when we created the `todoItems` and `todoInput` properties, we assign them to an empty observable. 
These observables can now be accessed and updated by another module, but _main_ doesn't know anything about this 
other module which preserves the pattern of loosely-coupled modules. Even though the _todo_ module passes
its content to these observables, it doesn't know anything about the _main_ module other
than what is explicitly shared via state.

You will find that all of the errors are gone, but unfortunately it is not styled. However,
functionally we are done with the _main_ module.

![Main module sans styles](./app1.png)

### Main Bindings

We did not need to declare bindings because we used `data-bind`, 
but we will be using `data-class` in some instances within the _todo_ module so that is when we will be creating
bindings.

### Main Styles

Styling main is simple and straight-forward. We used the [css](https://github.com/tastejs/todomvc/blob/gh-pages/architecture-examples/knockoutjs/bower_components/todomvc-common/base.css) that was provided by the [todomvc](http://todomvc.com/)
specification. We will just copy-and-paste the contents of this css file into __main.css__ which is located in the
__styles__ folder. In a future tutorial, we will cover how to use LESS in your modules.

![Main module with styles](./app2.png)

<br>

## 3. Create the todo Module

The todo module is responsible for the functionality needed in the todo list, such as adding, editing, and removing todos.
Making a new module is extremely easy because scalejs provides Visual Studio Item Templates
for modules. __Right-click__ on the __app__ folder and select __Add > New Item.__
From the Add New Item window, search for _scalejs_ and select the 
__Scalejs MVVM Module (CSS)__. Name this module _todo_ and click __Add__.

![Creating a new Module](./module1.png)

Once we create a module we need include it in the __app.js__ file by appending a comma and the name of the module
to the `scalejs!application` argument within the `require` function.

<sub>__app/app.js__</sub>
```javascript
require([
    'scalejs!application/main!!*,todo**!'
], function (
    application
) {
    'use strict';

    application.run();
});
```

This will not allow the todo module to work as intended as __todoModule.js__ is generated by the item template, 
but it needs to be modified slightly so that we are adding the todo state to the correct parent state.
Below is the todoModule.js file which is created by the module template.

<sub>__app/todo/todoModule.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo',
    'app/todo/viewmodels/todoViewModel',
    'bindings!todo',
    'views!todo',
    'styles!todo'
], function (
    sandbox,
    todoViewModel
) {
    'use strict';

    return function todoModule() {
        var // imports
            root = sandbox.mvvm.root,
            template = sandbox.mvvm.template,
            registerStates = sandbox.state.registerStates,
            state = sandbox.state.builder.state,
            onEntry = sandbox.state.builder.onEntry,
            // vars
            todo = todoViewModel(sandbox);

        // Register application state for the module.
        registerStates('app',
            state('todo',
                onEntry(function () {
                    // Render viewModel using 'main_template' template 
                    // (defined in main.html) and show it in the `root` region.
                    todo.text('Hello World from todo!');
                    root(template('todo_template', todo));
                })));
    };
});
```


As you can see above, the _todo_ state is defined as a child to the _app_ state. 
Since the _main_ state is also a child of the _app_ state,
the app can only be in either the _main_ state or the _todo_ state at a time. 
This means that our statechart looks like this:

![Bad statechart](./statechart1.png)

To remedy this, we can make _todo_ a child of the _main_ state by changing the statechart in __todoModule.js__.

<sub>__app/todo/todoModule.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo',
    'app/todo/viewmodels/todoViewModel',
    'bindings!todo',
    'views!todo',
    'styles!todo'
], function (
    sandbox,
    todoViewModel
) {
    'use strict';

    return function todoModule() {
        var // imports
            root = sandbox.mvvm.root,
            template = sandbox.mvvm.template,
            registerStates = sandbox.state.registerStates,
            state = sandbox.state.builder.state,
            onEntry = sandbox.state.builder.onEntry,
            // vars
            todo = todoViewModel(sandbox);

        // Register application state for the module.
        !!*registerStates('main',**!
            state('todo',
                onEntry(function () {
                    // Render viewModel using 'main_template' template 
                    // (defined in main.html) and show it in the `root` region.
                    todo.text('Hello World from todo!');
                    root(template('todo_template', todo));
                })));
    };
});

```

Now we have created this statechart:

![Good Statechart](./statechart2.png)

### Todo View

While _main_ view was responsible for the overall app layout, _todo_ is responsible for two views: one for the 
todo list, and the other for the todo input.

The template for the list is a little more complex than the
one for main. For now, we won't add any bindings; we will do that as we add functionality.

For now all we need to do is define the template so they can be rendered in the `todoItems` and `todoInput` regions defined in the _main_ view above.

<sub>__app/todo/views/todo.html__</sub>
```xml
<div id="todo_items_template">
    <section id="main">
		<input id="toggle-all" type="checkbox">
		<label for="toggle-all">Mark all as complete</label>
		<ul id="todo-list">
			<!-- These are here just to show the structure of the list items -->
			<!-- List items should get the class `editing` when editing and `completed` when marked as completed -->
			<li class="completed">
				<div class="view">
					<input class="toggle" type="checkbox" checked>
					<label>Create a TodoMVC template</label>
					<button class="destroy"></button>
				</div>
				<input class="edit" value="Create a TodoMVC template">
			</li>
			<li>
				<div class="view">
					<input class="toggle" type="checkbox">
					<label>Rule the web</label>
					<button class="destroy"></button>
				</div>
				<input class="edit" value="Rule the web">
			</li>
		</ul>
	</section>
	<!-- This footer should hidden by default and shown when there are todos -->
	<footer id="footer">
		<!-- This should be `0 items left` by default -->
		<span id="todo-count"><strong>1</strong> item left</span>
		<!-- Remove this if you don't implement routing -->
		<ul id="filters">
			<li>
				<a class="selected" href="#/">All</a>
			</li>
			<li>
				<a href="#/active">Active</a>
			</li>
			<li>
				<a href="#/completed">Completed</a>
			</li>
		</ul>
		<!-- Hidden if no completed items are left -->
		<button id="clear-completed">Clear completed (1)</button>
	</footer>
</div>

<div id="todo_input_template">
    <input id="new-todo" placeholder="What needs to be done?" autofocus>
</div>
```

In the boilerplate code for the _todo_ state we are passing the template (which no longer have defined within our view) to the
`root` which is wrong. It will cause the whole root element to be rendered to that view.
 Instead we should be passing the `todo_items_template` and the `todo_input_template` 
into the `todoItems` and `todoInput` observables we defined in the _main_ state.

<sub>__app/todo/todoModule.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo',
    'app/todo/viewmodels/todoViewModel',
    'bindings!todo',
    'views!todo',
    'styles!todo'
], function (
    sandbox,
    todoViewModel
) {
    'use strict';

    return function todoModule() {
        var // imports
            root = sandbox.mvvm.root,
            template = sandbox.mvvm.template,
            registerStates = sandbox.state.registerStates,
            state = sandbox.state.builder.state,
            onEntry = sandbox.state.builder.onEntry,
            // vars
            todo = todoViewModel(sandbox);

        // Register application state for the module.
        registerStates('main',
            state('todo',
                onEntry(function () {
                    !!*// pass the template bindings to the appropriate property
                    this.todoItems(template('todo_items_template', todo));
                    this.todoInput(template('todo_input_template', todo));**!
                })));
    };
});

```

This is all you need to display the _todo_ module in your app. Now if you refresh
your browser you will see a static version of the _todo_ module. 

![A Useless Web App!](./todo1.png)

<br>

## Functionality

The static app might look good, but as you can tell by clicking on it is completely
useless. We can fix this by adding functionality which we will do in incremental
steps so that you are able to follow along.

<br>

### 4. Hide main and footer when there are none

According to the spec, the element with the id `#main` and the element with the id `#footer`
must be hidden when there are no todos. To do this we need to have a data structure
to store the todos. We need to be able to know how many items are in this structure.
We also need to be able to add and remove items. Since we will be showing todos in our 
view, the view must be able to react to the changes in the structure.

To accomplish all of this we use an `observableArray` to store the items. 
Like with `observables`, if you are familiar with knockout.js this should be easy to do, but if not you can
learn about them in more detail [here](./mvvm.html#obseravles) and also on [knockout's website](http://knockoutjs.com/documentation/observables.html).
Since this is a requirement for the functionality of the _todo_ module it must be declared in the ViewModel.

<sub>__app/todo/viewmodels/todoViewModel.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo'
], function (
    sandbox
) {
    'use strict';

    return function () {
        !!*var observableArray = sandbox.mvvm.observableArray,
            //properties
            items = observableArray();**!

        return {
            !!*items: items**!
        };
    };
});
```

We need to hide `#main` and `#footer` if this array is empty. 
We can do this by defining a special data-class. 
To add a data-class to an element in your template is very simple and straightforward. 
We will add the data-class `todo-visible` in the `todo_items_template`.

<sub>__app/todo/views/todo.html__<sub>
```xml
<div id="todo_items_template">
    !!*<section id="main" data-class="todo-visible">**!
        <input id="toggle-all" type="checkbox">
        <label for="toggle-all">Mark all as complete</label>
        <ul id="todo-list">
            <!-- These are here just to show the structure of the list items -->
            <!-- List items should get the class `editing` when editing and `completed` when marked as completed -->
            <li class="completed">
                <div class="view">
                    <input class="toggle" type="checkbox" checked>
                    <label>Create a TodoMVC template</label>
                    <button class="destroy"></button>
                </div>
                <input class="edit" value="Create a TodoMVC template">
            </li>
            <li>
                <div class="view">
                    <input class="toggle" type="checkbox">
                    <label>Rule the web</label>
                    <button class="destroy"></button>
                </div>
                <input class="edit" value="Rule the web">
            </li>
        </ul>
    </section>

    !!*<footer id="footer" data-class="todo-visible">**!
        <!-- This should be `0 items left` by default -->
        <span id="todo-count"><strong>1</strong> item left</span>
        <!-- Remove this if you don't implement routing -->
        <ul id="filters">
            <li>
                <a class="selected" href="#/">All</a>
            </li>
            <li>
                <a href="#/active">Active</a>
            </li>
            <li>
                <a href="#/completed">Completed</a>
            </li>
        </ul>
        <!-- Hidden if no completed items are left -->
        <button id="clear-completed">Clear completed (1)</button>
    </footer>
</div>

<div id="todo_input_template">
    <input id="new-todo" placeholder="What needs to be done?" autofocus>
</div>
```

The reason we use data-class instead of data-bind is so that we do not have to include complicated
JavaScript within the html of our app. We can define the data-class in our bindings file.

Now we can define the logic behind the `todo-visible` data-class in __todoBindings.js__.

<sub>__app/todo/bindings/todoBindings.js__</sub>
```javascript
/*global define */
/*jslint sloppy: true*/
define({
    !!*'todo-visible': function () {
        return {
            visible: this.items().length > 0
        };
    }**!
});
```

After saving these files, refresh the browsers to observe the appropriate divs being hidden.

![Nothing to do!](./todohidden.png)

<br>

### 5. Adding a new todo

We need to let the user input a todo and when they hit enter it needs to be added to the list.
For this functionality, we need to bind the input to a new property of the viewmodel which will be implemented
using an observable. Let's call it `newItem`.

<sub>__app/todo/viewmodels/todoViewModel.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo'
], function (
    sandbox
) {
    'use strict';

    return function () {
        var !!*observable = sandbox.mvvm.observable,**!
            observableArray = sandbox.mvvm.observableArray,
            //properties
            items = observableArray(),
            !!*newItem = observable();**!

        return {
            items: items,
            !!*newItem: newItem**!
        };
    };
});
```

`newItem` must be bound to the _value_ binding of the input box so that as the user types,
the observable gets updated with what they type. We also need to instruct this observable
to update whenever a user hits a key (`afterkeydown` event) and to listen for the
`ENTER_KEY` so that the `newItem`  can be added to the `items` array.

Because we need to do so much with this input, we will assign a  data-class 
to it and name the data-class `todo-input`. This time, we are using a data-class because
there are so many bindings on this element and it will be cleaner to define
them outside of the html.

<sub>__app/todo/views/todo.html__</sub>
```xml
<div id="todo_items_template">
    <section id="main" data-class="todo-visible">
        <input id="toggle-all" type="checkbox">
        <label for="toggle-all">Mark all as complete</label>
        <ul id="todo-list">
            <!-- These are here just to show the structure of the list items -->
            <!-- List items should get the class `editing` when editing and `completed` when marked as completed -->
            <li class="completed">
                <div class="view">
                    <input class="toggle" type="checkbox" checked>
                    <label>Create a TodoMVC template</label>
                    <button class="destroy"></button>
                </div>
                <input class="edit" value="Create a TodoMVC template">
            </li>
            <li>
                <div class="view">
                    <input class="toggle" type="checkbox">
                    <label>Rule the web</label>
                    <button class="destroy"></button>
                </div>
                <input class="edit" value="Rule the web">
            </li>
        </ul>
    </section>

    <footer id="footer" data-class="todo-visible">
        <!-- This should be `0 items left` by default -->
        <span id="todo-count"><strong>1</strong> item left</span>
        <!-- Remove this if you don't implement routing -->
        <ul id="filters">
            <li>
                <a class="selected" href="#/">All</a>
            </li>
            <li>
                <a href="#/active">Active</a>
            </li>
            <li>
                <a href="#/completed">Completed</a>
            </li>
        </ul>
        <!-- Hidden if no completed items are left -->
        <button id="clear-completed">Clear completed (1)</button>
    </footer>
</div>

<div id="todo_input_template">
    !!*<input id="new-todo" data-class="todo-input" placeholder="What needs to be done?" autofocus>**!
</div>
```

Similarly to `todo-visible`, we must add a definition for this class in __todoBindings.js__

<sub>__app/todo/bindings/todoBindings.js__</sub>
```javascript
/*global define */
/*jslint sloppy: true*/
define({
    'todo-visible': function () {
        return {
            visible: this.items().length > 0
        };
    !!*},
    'todo-input': function () {
        return {
            value: this.newItem,
            valueUpdate: 'afterkeydown'
        };**!
    }
});
```
With these bindings, we are listening for user input and updating `newItem` whenever
the user presses a key.

You might be wondering a few things about how [bindings](./mvvm.html#bindings) work.
`this` contains a reference to the viewmodel within the context of this binding.
Usually this is the viewmodel for the module, but in some cases (such as the foreach binding)
it will be something else. We will explain this in more detail when we implement
displaying the todos in a list.

Also, we are prefixing all of our data-class names with the name of the module 
(e.g. _todo-_) because we want to make it cleaner for a developer to know what module a 
data-class belongs to by looking at its class name.

Now we need to add the logic so that when one presses enter a new todo is added to the list. 
First lets create a function in __todoViewModel.js__ to do so. We will call it `addItem`.

<sub>__app/todo/viewmodels/todoViewModel.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo'
], function (
    sandbox
) {
    'use strict';

    return function () {
        var observable = sandbox.mvvm.observable,
            observableArray = sandbox.mvvm.observableArray,
            !!*has = sandbox.object.has,**!
            //properties
            items = observableArray(),
            newItem = observable();

        !!*function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                items.push(item.trim());
            }
            newItem("");
        }**!

        return {
            items: items,
            newItem: newItem,
            !!*addItem: addItem**!
        };
    };
});
```

In `addItem` we use the [has](./api.html#has) function so
be sure to include it from the sandbox. `has` can be found in the `object` namespace and we
use it to make sure that the item has the `trim` function before we attempt to call it.

The next step is making sure this function gets called when the user hits enter. We can do that by defining an
event binding in the `todo-input` data-class we defined from before.

<sub>__app/todo/bindings/todoBindings.js__</sub>
```javascript
/*global define */
!!*/*jslint sloppy: true,unparam: true*/**!
!!*define(function () {
    var ENTER_KEY = 13;
    return {**!
        'todo-visible': function () {
            return {
                visible: this.items().length > 0
            };
        },
        !!*'todo-input': function () {
            var addItem = this.addItem;
            return {
                value: this.newItem,
                valueUpdate: 'afterkeydown',
                event: {
                    keyup: function (data, e) {
                        if (e.keyCode === ENTER_KEY) {
                            addItem();
                        }
                    }
                }
            };
        }
    };**!
});
```

Since we defined a function for the event, we lost the context of the outer function so we 
cannot use `this` to get our viewModel properties. To fix this we define a var at the top of the data-class
with the same name as the function 
we want to use (`addItem`) and assigned the function defined in `this` to the var.

We also converted our bindings object to a function which will return the bindings object, so that we can define
'global' vars (which are local to the function containing the bindings) which will let us reuse constants like `ENTER_KEY`
in our bindings. We will need it again for editing an item, so it's good to do this now.

If you refresh the page now and try adding an item, you will see that entering
an item and will clear the input and show some todos, but since we haven't
implemented showing todos it won't actually display the todo you just entered.

<br>

### 6. Displaying todos in the list
      
We need to make sure the todos are being displayed in the list.
Right now we're not binding the list to anything - but the fix is very simple. 
We can bind the `ul` element to the items array using the `foreach` binding. The contents
of the `ul` will be repeated for each item in the list, with the item providing the 
context for the binding.

<sub>__app/todo/views/todo.html__</sub>
```xml
<div id="todo_items_template">
    <section id="main" data-class="todo-visible">
        <input id="toggle-all" type="checkbox">
        <label for="toggle-all">Mark all as complete</label>
        !!*<ul id="todo-list" data-bind="foreach: items">**!
            <li class="completed">
                <div class="view">
                    <input class="toggle" type="checkbox" checked>
                    !!*<label data-bind="text: $data"></label>**!
                    <button class="destroy"></button>
                </div>
                <input class="edit" value="Create a TodoMVC template">
            </li>
        </ul>
    </section>

    <footer id="footer" data-class="todo-visible">
        <!-- This should be `0 items left` by default -->
        <span id="todo-count"><strong>1</strong> item left</span>
        <!-- Remove this if you don't implement routing -->
        <ul id="filters">
            <li>
                <a class="selected" href="#/">All</a>
            </li>
            <li>
                <a href="#/active">Active</a>
            </li>
            <li>
                <a href="#/completed">Completed</a>
            </li>
        </ul>
        <!-- Hidden if no completed items are left -->
        <button id="clear-completed">Clear completed (1)</button>
    </footer>
</div>

<div id="todo_input_template">
    <input id="new-todo" data-class="todo-input" placeholder="What needs to be done?" autofocus>
</div>
```

Instead of using a data-class we just used a `data-bind` attribute like we did in the `main_template` with `render`. 
`foreach` is a knockout binding which will take the contents of the div and render it as a template for each
item within the array `foreach` is bound to. You can learn more about it [here](http://knockoutjs.com/documentation/foreach-binding.html)

After saving these files, refresh the browser to observe the ability to add items to the list.

![Adding items to the list](./todo3.png)

But this isn't enough. We also need to do a little extra work when adding an item so that it shows 
as completed only when it is completed. To do this, we need to alter the item so
it is an object with two properties: `title` and `completed`.. 
In __todoViewModel.js__ make the following change to the item when it is pushed to the items array.

<sub>__app/todo/viewmodels/todoViewModel.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo'
], function (
    sandbox
) {
    'use strict';

    return function () {
        var observable = sandbox.mvvm.observable,
            observableArray = sandbox.mvvm.observableArray,
            has = sandbox.object.has,
            //properties
            items = observableArray(),
            newItem = observable();

        function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                !!*items.push({
                    title: item.trim(),
                    completed: observable(false)
                });**!
            }
            newItem("");
        }

        return {
            items: items,
            newItem: newItem,
            addItem: addItem
        };
    };
});
```

In `todo_items_template` also edit the li element so that it is being bound to the title
and the completed properties.

<sub>__app/todo/views/todo.html__</sub>
```xml
<div id="todo_items_template">
    <section id="main" data-class="todo-visible">
        <input id="toggle-all" type="checkbox">
        <label for="toggle-all">Mark all as complete</label>
        <ul id="todo-list" data-bind="foreach: items">
            !!*<li data-bind="css: { completed: completed }">**!
                <div class="view">
                    !!*<input class="toggle" type="checkbox" data-bind="checked: completed">**!
                    !!*<label data-bind="text: title"></label>**!
                    <button class="destroy"></button>
                </div>
                <input class="edit" value="Create a TodoMVC template">
            </li>
        </ul>
    </section>

    <footer id="footer" data-class="todo-visible">
        <!-- This should be `0 items left` by default -->
        <span id="todo-count"><strong>1</strong> item left</span>
        <!-- Remove this if you don't implement routing -->
        <ul id="filters">
            <li>
                <a class="selected" href="#/">All</a>
            </li>
            <li>
                <a href="#/active">Active</a>
            </li>
            <li>
                <a href="#/completed">Completed</a>
            </li>
        </ul>
        <!-- Hidden if no completed items are left -->
        <button id="clear-completed">Clear completed (1)</button>
    </footer>
</div>

<div id="todo_input_template">
    <input id="new-todo" data-class="todo-input" placeholder="What needs to be done?" autofocus>
</div>
```

Now the completed class is only added if the item's `completed`
property is true. At the same time, we are also able to toggle this class on and off when we check or uncheck 
the item because we have bound the checkbox input to the `checked` binding. Since `completed` is an observable, 
when we check the item, `completed` becomes true, so the css completed is applied to the list item.

After saving these files, refresh the browsers to observe that checking/unchecking the checkbox applies the 
appropriate class to the list item.

![Now we can add items to the todo list](./todo2.png)

<br>

### 7. Mark all as complete

We need to mark all of the items as completed when we click on the arrow
to the left of the input box. We use a `computed` property to do this. Computed properties
are more complex than observables but are very useful once you understand them.
You can read more about computed properties [here](http://knockoutjs.com/documentation/computedObservables.html). 

The computed will re-evaluate any time an observable within it changes. 
We can use this to react to the `items` and return true when they are all checked
to indicate to the 'mark all as complete' arrow that it should be 'checked'

<sub>__app/todo/viewmodels/todoViewModel.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo'
], function (
    sandbox
) {
    'use strict';

    return function () {
        var observableArray = sandbox.mvvm.observableArray,
            observable = sandbox.mvvm.observable,
            has = sandbox.object.has,
            !!*computed = sandbox.mvvm.computed,**!
            //properties
            items = observableArray(),
            newItem = observable()!!*,
            checkAll;**!

        function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                items.push({
                    title: item.trim(),
                    completed: observable(false)
                });
            }
            newItem("");
        }

        !!*checkAll = computed({
            read: function () {
                return items().all("$.completed()");
            }
        });**!

        return {
            items: items,
            newItem: newItem,
            addItem: addItem,
            !!*checkAll: checkAll**!
        };
    };
});
```

An interesting thing to note about our implementation of the `read` function is that we
are using the `all` function which we get from [linq.js](http://linqjs.codeplex.com/). In JavaScript apps you need to
manipulate arrays/lists/collections quite
often and therefore need more sophisticated functionality than what is provided by JavaScript.
This is why we expose all of linq's functions on the Array's prototype. 

We bind the computed property to the `toggle-all` checkbox like so:

<sub>__app/todo/views/todo.html__</sub>
```xml
<div id="todo_items_template">
    <section id="main" data-class="todo-visible">
        !!*<input id="toggle-all" type="checkbox" data-bind="checked: checkAll">**!
        <label for="toggle-all">Mark all as complete</label>
        <ul id="todo-list" data-bind="foreach: items">
            <li data-bind="css: { completed: completed }">
                <div class="view">
                    <input class="toggle" type="checkbox" data-bind="checked: completed">
                    <label data-bind="text: title"></label>
                    <button class="destroy"></button>
                </div>
                <input class="edit" value="Create a TodoMVC template">
            </li>
        </ul>
    </section>

    <footer id="footer" data-class="todo-visible">
        <!-- This should be `0 items left` by default -->
        <span id="todo-count"><strong>1</strong> item left</span>
        <!-- Remove this if you don't implement routing -->
        <ul id="filters">
            <li>
                <a class="selected" href="#/">All</a>
            </li>
            <li>
                <a href="#/active">Active</a>
            </li>
            <li>
                <a href="#/completed">Completed</a>
            </li>
        </ul>
        <!-- Hidden if no completed items are left -->
        <button id="clear-completed">Clear completed (1)</button>
    </footer>
</div>

<div id="todo_input_template">
    <input id="new-todo" data-class="todo-input" placeholder="What needs to be done?" autofocus>
</div>
```

Now if you add a new item then mark it as complete, you will see the toggle-all 
checkbox is darker (e.g. it is checked). This checkbox will be checked if and
only if all the items in the list are checked. But if you click on this checkbox,
you are not able to change its value or update the items to be marked as completed
or not completed. We can fix this by giving this computed property a `write` function
which will take whatever value it is given and apply it to all the items' `completed` 
properties.

<sub>__app/todo/viewmodels/todoViewModel.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo'
], function (
    sandbox
) {
    'use strict';

    return function () {
        var observableArray = sandbox.mvvm.observableArray,
            observable = sandbox.mvvm.observable,
            has = sandbox.object.has,
            computed = sandbox.mvvm.computed,
            //properties
            items = observableArray(),
            newItem = observable(),
            checkAll;

        function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                items.push({
                    title: item.trim(),
                    completed: observable(false)
                });
            }
            newItem("");
        }

        !!*checkAll = computed({
            read: function () {
                return items().all("$.completed()");
            },
            write: function (value) {
                items().forEach(function (item) { item.completed(value); });
            }
        });**!

        return {
            items: items,
            newItem: newItem,
            addItem: addItem,
            checkAll: checkAll
        };
    };
});
```

Now your app can mark/unmark all items as completed. Save and refresh to see it
in action.

<br>

### 8. Editing a todo

For this functionality we need to modify the `li` element a bit. We need to define a new
data-class for the element because we need to add more bindings and having any more than
one or two bindings on an html element looks ugly. We will give it the `todo-item` data-class.

We also need to add a data-class to the input element so that we can toggle editing on
and off. We will call this the `todo-edit` class.

<sub>__app/todo/views/todo.html__</sub>
```xml
<div id="todo_items_template">
    <section id="main" data-class="todo-visible">
        <input id="toggle-all" type="checkbox" data-bind="checked: checkAll">
        <label for="toggle-all">Mark all as complete</label>
        <ul id="todo-list" data-bind="foreach: items">
            !!*<li data-class="todo-item">**!
                <div class="view">
                    <input class="toggle" type="checkbox" data-bind="checked: completed" />
                    <label data-bind="text: title"></label>
                    <button class="destroy"></button>
                </div>
                !!*<input class="edit" data-class="todo-edit" />**!
            </li>
        </ul>
    </section>

    <footer id="footer" data-class="todo-visible">
        <!-- This should be `0 items left` by default -->
        <span id="todo-count"><strong>1</strong> item left</span>
        <!-- Remove this if you don't implement routing -->
        <ul id="filters">
            <li>
                <a class="selected" href="#/">All</a>
            </li>
            <li>
                <a href="#/active">Active</a>
            </li>
            <li>
                <a href="#/completed">Completed</a>
            </li>
        </ul>
        <!-- Hidden if no completed items are left -->
        <button id="clear-completed">Clear completed (1)</button>
    </footer>
</div>

<div id="todo_input_template">
    <input id="new-todo" data-class="todo-input" placeholder="What needs to be done?" autofocus>
</div>
```

In the `todo-item` data-class, not only do we need to repeat the binding we had previously
defined inline in the html, we also need to apply an `editing` class if the item is being 
edited. We begin editing an item when we double-click on an item, so we also bind a function 
called `beginEdit` to this event.

<sub>__app/todo/bindings/todoBindings.html__</sub>
```javascript
/*global define */
/*jslint sloppy: true,unparam: true*/
define(function () {
    var ENTER_KEY = 13;
    return {
        'todo-visible': function () {
            return {
                visible: this.items().length > 0
            };
        },
        'todo-input': function () {
            var addItem = this.addItem;
            return {
                value: this.newItem,
                valueUpdate: 'afterkeydown',
                event: {
                    keyup: function (data, e) {
                        if (e.keyCode === ENTER_KEY) {
                            addItem();
                        }
                    }
                }
            };
        }!!*,
        'todo-item': function () {
            return {
                css: {
                    completed: this.completed,
                    editing: this.editMode
                },
                event: {
                    dblclick: this.beginEdit
                }
            };
        }**!
    };
});
```

Since the `li` element is bound to an item, this means we have created two new properties
which need to be exposed on an item: `editMode` which is a boolean indicating if the item
is currently being edited, and `beginEdit` which is a function which will begin editing
on the item

The introduction of these two new properties on the item means that the item is getting
more and more complex. We also will need to add more properties and methods as we continue
to implement functionality, so the wise thing to do is to move the item to its own viewmodel in a separate file.

We will define a new viewmodel in the __viewmodels__ folder for _todo_ and name it __itemViewModel.js__.

![new item](./newitem.png)

Copy and paste the code below or follow the pattern that the _main_ and _todo_ viewmodels use,
except do not declare any properties or return anything.

<sub>__app/todo/viewmodels/itemViewModel.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo'
], function (
    sandbox
) {
    'use strict';

    return function () {
      
        return {
            
        };
    };
});
```

We will reference this viewmodel from the __todoViewModel__ when we make a new item. 
We need to pass to this viewmodel the title of the item and the status of its
completion (when we create an item, it will always be false - but making
this a parameter will come in handy when we implement persistence)

<sub>__app/todo/viewmodels/todoViewModel.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo'!!*,
    'app/todo/viewmodels/itemViewModel'**!
], function (
    sandbox!!*,
    itemViewModel**!
) {
    'use strict';

    return function () {
        var observableArray = sandbox.mvvm.observableArray,
            observable = sandbox.mvvm.observable,
            has = sandbox.object.has,
            computed = sandbox.mvvm.computed,
            //properties
            items = observableArray(),
            newItem = observable(),
            checkAll;

        function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                !!*items.push(itemViewModel({ title: item, completed: false }));**!
            }
            newItem("");
        }

        checkAll = computed({
            read: function () {
                return items().all("$.completed()");
            },
            write: function (value) {
                items().forEach(function (item) { item.completed(value); });
            }
        });

        return {
            items: items,
            newItem: newItem,
            addItem: addItem,
            checkAll: checkAll
        };
    };
});
```

Now we can recreate the functionality from before, and also add the new properties `editMode` and `beginEdit`

<sub>__app/todo/viewmodels/itemViewModel.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo'
], function (
    sandbox
) {
    'use strict';

    !!*return function (item) {**!
        !!*var observable = sandbox.mvvm.observable,
            //properties
            title = observable(item.title),
            completed = observable(item.completed),
            editMode = observable(false);**!

        !!*function beginEdit() {
            editMode(true);
        }**!

        return {
            !!*title: title,
            completed: completed,
	        editMode: editMode,
            beginEdit: beginEdit**!
        };
    };
});
```

This time, we made `title` an observable because when we are editing an item, presumably
we will need to change its title. `beginEdit` simply sets the `editMode` observable to true.

Beginning an edit is rather useless if we are unable to end it. To do this, we now will 
define the data-class `todo-edit` to listen for user input, update the value of title, and
end edit mode.

<sub>__app/todo/bindings/todoBindings.js__</sub>
```javascript
/*global define */
/*jslint sloppy: true,unparam: true*/
define(function () {
    var ENTER_KEY = 13;
    return {
        'todo-visible': function () {
            return {
                visible: this.items().length > 0
            };
        },
        'todo-input': function () {
            var addItem = this.addItem;
            return {
                value: this.newItem,
                valueUpdate: 'afterkeydown',
                event: {
                    keyup: function (data, e) {
                        if (e.keyCode === ENTER_KEY) {
                            addItem();
                        }
                    }
                }
            };
        },
        'todo-item': function () {
            return {
                css: {
                    completed: this.completed,
                    editing: this.editMode
                },
                event: {
                    dblclick: this.beginEdit
                }
            };
        },
        !!*'todo-edit': function () {
            var item = this;

            return {
                value: this.title,
                valueUpdate: 'afterkeydown',
                event: {
                    keyup: function (data, e) {
                        if (e.keyCode === ENTER_KEY) {
                            item.endEdit();
                        }
                    },
                    blur: function () {
                        item.endEdit();
                    }
                },
                hasFocus: this.editMode
            };
        }**!
    };
});
```

`value` and `valueUpdate` should be ring a bell. `hasFocus` is bound to the `editMode` property
so that when `editMode` is entered, the input automatically is given focus. Also, on the blur event,
we make sure to call `item.endEdit()` so that it also ends the edit on blur. `endEdit` still
needs to be defined in order for this to come full-circle.

<sub>__app/todo/viewmodels/itemViewModel.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo'
], function (
    sandbox
) {
    'use strict';

    return function (item) {
        var observable = sandbox.mvvm.observable,
            //properties
            title = observable(item.title),
            completed = observable(item.completed),
            editMode = observable(false);

        function beginEdit() {
            editMode(true);
        }

        !!*function endEdit() {
            var newTitle = title().trim();
            if (newTitle) {
                title(newTitle);
                editMode(false);
            } else {
                //we need to remove the item
                //if the title is an empty string
            }
        }**!

        return {
            title: title,
            completed: completed,
            editMode: editMode,
            beginEdit: beginEdit,
            !!*endEdit: endEdit**!
        };
    };
});
```

Now you can edit an item by double clicking on it, entering a new title, and hitting 'enter'. 

<br>

### 9. Removing an item

An item can be removed in two ways: by clicking on the 'x' that appears when you move the mouse over it, or
by changing the item to an empty string

An `observableArray` has a method, `remove`, which can remove an item from the array if it is passed
a reference to the item. We can use this function to remove our items by calling  `items.remove(item)`. 

We will give the itemViewModel its own `remove` function which will, in turn, call `items.remove(this)`.
However the itemViewModel does not have `items` so we must pass the `items` to the `itemViewModel` so
we can access the remove function.

<sub>__app/todo/viewmodels/itemViewModel.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo'
], function (
    sandbox
) {
    'use strict';

    return function (item!!*, items**!) {
        var observable = sandbox.mvvm.observable,
            //properties
            title = observable(item.title),
            completed = observable(item.completed),
            editMode = observable(false);

        function beginEdit() {
            editMode(true);
        }

        function endEdit() {
            var newTitle = title().trim();
            if (newTitle) {
                title(newTitle);
                editMode(false);
            } else {
                items.remove(this);
            }
        }

        !!*function remove() {
            items.remove(this);
        }**!

        return {
            title: title,
            completed: completed,
            editMode: editMode,
            beginEdit: beginEdit,
            endEdit: endEdit!!*,
            remove: remove**!
        };
    };
});
```

Now we also need to modify the __todoViewModel__ so that we are passing the items to the viewmodel.

<sub>__app/todo/viewmodels/todoViewModel.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo',
    'app/todo/viewmodels/itemViewModel'
], function (
    sandbox,
    itemViewModel
) {
    'use strict';

    return function () {
        var observableArray = sandbox.mvvm.observableArray,
            observable = sandbox.mvvm.observable,
            has = sandbox.object.has,
            computed = sandbox.mvvm.computed,
            //properties
            items = observableArray(),
            newItem = observable(),
            checkAll;

        function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                items.push(itemViewModel({ title: item, completed: false }!!*, items**!));
            }
            newItem("");
        }

        checkAll = computed({
            read: function () {
                return items().all("$.completed()");
            },
            write: function (value) {
                items().forEach(function (item) { item.completed(value); });
            }
        });

        return {
            items: items,
            newItem: newItem,
            addItem: addItem,
            checkAll: checkAll
        };
    };
});
```

Now all we need to do is bind the 'x' button in the view to this function

<sub>__app/todo/views/todo.html__</sub>
```xml
<div id="todo_items_template">
    <section id="main" data-class="todo-visible">
        <input id="toggle-all" type="checkbox" data-bind="checked: checkAll">
        <label for="toggle-all">Mark all as complete</label>
        <ul id="todo-list" data-bind="foreach: items">
            <li data-class="todo-item">
                <div class="view">
                    <input class="toggle" type="checkbox" data-bind="checked: completed" />
                    <label data-bind="text: title"></label>
                    !!*<button class="destroy" data-bind="click: remove"></button>**!
                </div>
                <input class="edit" data-class="todo-edit" />
            </li>
        </ul>
    </section>

    <footer id="footer" data-class="todo-visible">
        <!-- This should be `0 items left` by default -->
        <span id="todo-count"><strong>1</strong> item left</span>
        <!-- Remove this if you don't implement routing -->
        <ul id="filters">
            <li>
                <a class="selected" href="#/">All</a>
            </li>
            <li>
                <a href="#/active">Active</a>
            </li>
            <li>
                <a href="#/completed">Completed</a>
            </li>
        </ul>
        <!-- Hidden if no completed items are left -->
        <button id="clear-completed">Clear completed (1)</button>
    </footer>
</div>

<div id="todo_input_template">
    <input id="new-todo" data-class="todo-input" placeholder="What needs to be done?" autofocus>
</div>
```

When the `remove` function is called, it will have the item passed to it (this is default behavior),
so it will work as expected. Refresh the page and try to remove an item if you do not believe me. 
Do this by clicking on the x, or editing an item and making it an empty string.

<br>

### 10. Cancel edit on escape

We also need to cancel the edit if the user hits 'escape'. To do this we introduce a private variable
in our itemViewModel which stores the current title when an edit begins. We also need to implement
a `cancelEdit` function which will restore the previous title.

<sub>__app/todo/viewmodels/itemViewModel.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo'
], function (
    sandbox
) {
    'use strict';

    return function (item, items) {
        var observable = sandbox.mvvm.observable,
            //properties
            title = observable(item.title),
            completed = observable(item.completed),
            editMode = observable(false),
			 !!*previousTitle;**!

        function beginEdit() {
            !!*previousTitle = this.title();**!
            editMode(true);
        }

        function endEdit() {
            var newTitle = title().trim();
            if (newTitle) {
                title(newTitle);
                editMode(false);
            } else {
                items.remove(this);
            }
        }

        function remove() {
            items.remove(this);
        }

        !!*function cancelEdit() {
            title(previousTitle);
            editMode(false);
        }**!

        return {
            title: title,
            completed: completed,
            editMode: editMode,
            beginEdit: beginEdit,
            endEdit: endEdit,
            remove: remove!!*,
            cancelEdit: cancelEdit**!
        };
    };
});
```

Also we have to modify the binding to call 'cancelEdit' if the user presses the `ESCAPE_KEY`

<sub>__app/todo/viewmodels/todoBindings.js__</sub>
```javascript
/*global define */
/*jslint sloppy: true,unparam: true*/
define(function () {
    var ENTER_KEY = 13!!*,
        ESCAPE_KEY = 27;**!

    return {
        'todo-visible': function () {
            return {
                visible: this.items().length > 0
            };
        },
        'todo-input': function () {
            var addItem = this.addItem;
            return {
                value: this.newItem,
                valueUpdate: 'afterkeydown',
                event: {
                    keyup: function (data, e) {
                        if (e.keyCode === ENTER_KEY) {
                            addItem();
                        }
                    }
                }
            };
        },
        'todo-item': function () {
            return {
                css: {
                    completed: this.completed,
                    editing: this.editMode
                },
                event: {
                    dblclick: this.beginEdit
                }
            };
        },
        'todo-edit': function () {
            var item = this;

            return {
                value: this.title,
                valueUpdate: 'afterkeydown',
                event: {
                    keyup: function (data, e) {
                        if (e.keyCode === ENTER_KEY) {
                            item.endEdit();
                        }!!* else if (e.keyCode === ESCAPE_KEY) {
                            item.cancelEdit();
                        }**!
                    },
                    blur: function () {
                        item.endEdit();
                    }
                },
                hasFocus: this.editMode
            };
        }
    };
});
```

This can be tested by editing an item and instead of hitting the enter key, hit the escape key. 
The previous title will be restored.

There are still some issues with the view not displaying the correct data so this is next on our list.

<br>

### 11. Display the Current Number of Items

The tricky thing about this is the fact that we need to put the number in a `<strong>` tag, but right next
to it we need to also display some text. This is where virtual bindings also help, since we want
to bind something without introducing a new parent div. We will define a data-class, `todo-count-text`, 
which will display the grammatically correct form of 'items' based on the #. We will bind the `<strong>` element
directly to the number of items (e.g. `length`)

<sub>__app/todo/views/todo.html__</sub>
```xml
<div id="todo_items_template">
    <section id="main" data-class="todo-visible">
        <input id="toggle-all" type="checkbox" data-bind="checked: checkAll">
        <label for="toggle-all">Mark all as complete</label>
        <ul id="todo-list" data-bind="foreach: items">
            <li data-class="todo-item">
                <div class="view">
                    <input class="toggle" type="checkbox" data-bind="checked: completed" />
                    <label data-bind="text: title"></label>
                    <button class="destroy" data-bind="click: remove"></button>
                </div>
                <input class="edit" data-class="todo-edit" />
            </li>
        </ul>
    </section>

    <footer id="footer" data-class="todo-visible">
        !!*<span id="todo-count">
            <strong data-bind="text: items().length"></strong>
            <!-- ko class:todo-count-text -->
            <!-- /ko -->
        </span>**!
        <!-- Remove this if you don't implement routing -->
        <ul id="filters">
            <li>
                <a class="selected" href="#/">All</a>
            </li>
            <li>
                <a href="#/active">Active</a>
            </li>
            <li>
                <a href="#/completed">Completed</a>
            </li>
        </ul>
        <!-- Hidden if no completed items are left -->
        <button id="clear-completed">Clear completed (1)</button>
    </footer>
</div>

<div id="todo_input_template">
    <input id="new-todo" data-class="todo-input" placeholder="What needs to be done?" autofocus>
</div>
```

`todo-count-text` needs to be defined:

<sub>__app/todo/bindings/todoBindings.js__</sub>
```javascript
/*global define */
/*jslint sloppy: true,unparam: true*/
define(function () {
    var ENTER_KEY = 13,
        ESCAPE_KEY = 27;

    return {
        'todo-visible': function () {
            return {
                visible: this.items().length > 0
            };
        },
        'todo-input': function () {
            var addItem = this.addItem;
            return {
                value: this.newItem,
                valueUpdate: 'afterkeydown',
                event: {
                    keyup: function (data, e) {
                        if (e.keyCode === ENTER_KEY) {
                            addItem();
                        }
                    }
                }
            };
        },
        'todo-item': function () {
            return {
                css: {
                    completed: this.completed,
                    editing: this.editMode
                },
                event: {
                    dblclick: this.beginEdit
                }
            };
        },
        'todo-edit': function () {
            var item = this;

            return {
                value: this.title,
                valueUpdate: 'afterkeydown',
                event: {
                    keyup: function (data, e) {
                        if (e.keyCode === ENTER_KEY) {
                            item.endEdit();
                        } else if (e.keyCode === ESCAPE_KEY) {
                            item.cancelEdit();
                        }
                    },
                    blur: function () {
                        item.endEdit();
                    }
                },
                hasFocus: this.editMode
            };
        }!!*,
        'todo-count-text': function () {
            return {
                text: (this.items().length === 1 ? 'item' : 'items') + ' left'
            };
        }**!
    };
});
```

Now the count has been implemented:

![Now I know how many items there are!](./count.png)

<br>

### 12. Clear completed

We will introduce a new data-class, `todo-clear-completed`, to allow the users to clear all of the
completed items with just one click.

<sub>__app/todo/views/todo.html__</sub>
```xml
<div id="todo_items_template">
    <section id="main" data-class="todo-visible">
        <input id="toggle-all" type="checkbox" data-bind="checked: checkAll">
        <label for="toggle-all">Mark all as complete</label>
        <ul id="todo-list" data-bind="foreach: items">
            <li data-class="todo-item">
                <div class="view">
                    <input class="toggle" type="checkbox" data-bind="checked: completed" />
                    <label data-bind="text: title"></label>
                    <button class="destroy" data-bind="click: remove"></button>
                </div>
                <input class="edit" data-class="todo-edit" />
            </li>
        </ul>
    </section>

    <footer id="footer" data-class="todo-visible">
        <span id="todo-count">
            <strong data-bind="text: items().length"></strong>
            <!-- ko class:todo-count-text -->
            <!-- /ko -->
        </span>
        <!-- Remove this if you don't implement routing -->
        <ul id="filters">
            <li>
                <a class="selected" href="#/">All</a>
            </li>
            <li>
                <a href="#/active">Active</a>
            </li>
            <li>
                <a href="#/completed">Completed</a>
            </li>
        </ul>
        !!*<button id="clear-completed" data-class="todo-clear-completed"></button>**!
    </footer>
</div>

<div id="todo_input_template">
    <input id="new-todo" data-class="todo-input" placeholder="What needs to be done?" autofocus>
</div>
```

This data class needs to support 3 things:

* Hide the element if there are no completed items
* Show the number of completed items
* Remove all completed items on click

We implement the binding like so:

<sub>__app/todo/bindings/todoBindings.js__</sub>
```javascript
/*global define */
/*jslint sloppy: true,unparam: true*/
define(function () {
    var ENTER_KEY = 13,
        ESCAPE_KEY = 27;

    return {
        'todo-visible': function () {
            return {
                visible: this.items().length > 0
            };
        },
        'todo-input': function () {
            var addItem = this.addItem;
            return {
                value: this.newItem,
                valueUpdate: 'afterkeydown',
                event: {
                    keyup: function (data, e) {
                        if (e.keyCode === ENTER_KEY) {
                            addItem();
                        }
                    }
                }
            };
        },
        'todo-item': function () {
            return {
                css: {
                    completed: this.completed,
                    editing: this.editMode
                },
                event: {
                    dblclick: this.beginEdit
                }
            };
        },
        'todo-edit': function () {
            var item = this;

            return {
                value: this.title,
                valueUpdate: 'afterkeydown',
                event: {
                    keyup: function (data, e) {
                        if (e.keyCode === ENTER_KEY) {
                            item.endEdit();
                        } else if (e.keyCode === ESCAPE_KEY) {
                            item.cancelEdit();
                        }
                    },
                    blur: function () {
                        item.endEdit();
                    }
                },
                hasFocus: this.editMode
            };
        },
        'todo-count-text': function () {
            return {
                text: (this.items().length === 1 ? 'item' : 'items') + ' left'
            };
        }!!*,
        'todo-clear-completed': function () {
            return {
                visible: this.completedItems().length > 0,
                text: 'Clear completed (' + this.completedItems().length + ')',
                click: this.removeCompletedItems
            };
        }**!
    };
});
```

We referenced two new things here: a `completedItems` variable and a `removeCompletedItems` function,
therefore we must define them in the viewmodel.

<sub>__app/todo/viewmodels/todoViewModels.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo',
    'app/todo/viewmodels/itemViewModel'
], function (
    sandbox,
    itemViewModel
) {
    'use strict';

    return function () {
        var observableArray = sandbox.mvvm.observableArray,
            observable = sandbox.mvvm.observable,
            has = sandbox.object.has,
            computed = sandbox.mvvm.computed,
            //properties
            items = observableArray(),
            newItem = observable(),
            checkAll!!*,
            completedItems;**!

        function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                items.push(itemViewModel({ title: item, completed: false }, items));
            }
            newItem("");
        }

        !!*function removeCompletedItems() {
            completedItems().forEach(function (item) {
                item.remove();
            });
        }**!

        checkAll = computed({
            read: function () {
                return items().all("$.completed()");
            },
            write: function (value) {
                items().forEach(function (item) { item.completed(value); });
            }
        });

        !!*completedItems = computed(function () {
            return items().where("$.completed()").toArray();
        });**!

        return {
            items: items,
            newItem: newItem,
            addItem: addItem,
            checkAll: checkAll!!*,
            completedItems: completedItems,
            removeCompletedItems: removeCompletedItems**!
        };
    };
});
```

As per scalejs convention, we define our functions after we define vars, and leave business logic to the end. 

For `removeCompletedItems`, we simply iterate through each item (using `Array.prototype.forEach`) and
pass an anonymous function which will call `remove()` on each completed item.

`completedItems` is a computed which will return the items where completed() is true. Again we are using
[linq](./best.html#linq) but this time since we want to return an array (`linq` functions cast arrays to enumerable
by default) we need to call `toArray()` before it is returned.

Now you can see this is working by refreshing your page, adding items, marking some as completed and observing
the value of _clear completed_ changing. Click on the button to remove all of the completed items.

<br>

### 13. Persistence

For persistence we will use `localStorage` to store and retrieve todos. Doing so will be very clean and concise
using `linq` and functional programming concepts.

We create two helper functions: `toItem` so that we can convert the `itemViewModel` to a plain object literal (so we
can stringify it and store it in `localStorage`) and `toItemViewModel` so we can convert items from `localStorage`
to an `itemViewModel`

Since we are using `localStorage` we need to add it to the global vars so that JSLint won't complain.

<sub>__app/todo/viewmodels/todoViewModel.js__</sub>
```javascript
/*global define!!*,localStorage**! */
define([
    'sandbox!todo',
    'app/todo/viewmodels/itemViewModel'
], function (
    sandbox,
    itemViewModel
) {
    'use strict';

    return function () {
        var observableArray = sandbox.mvvm.observableArray,
            observable = sandbox.mvvm.observable,
            has = sandbox.object.has,
            computed = sandbox.mvvm.computed,
            //properties
            items = observableArray(),
            newItem = observable(),
            checkAll,
            completedItems;

        !!*function toItem(itemVM) {
            return {
                title: itemVM.title(),
                completed: itemVM.completed()
            };
        }**!

        !!*function toItemViewModel(item) {
            return itemViewModel(item, items);
        }**!

        function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                items.push(itemViewModel({ title: item, completed: false }, items));
            }
            newItem("");
        }

        function removeCompletedItems() {
            completedItems().forEach(function (item) {
                item.remove();
            });
        }

        checkAll = computed({
            read: function () {
                return items().all("$.completed()");
            },
            write: function (value) {
                items().forEach(function (item) { item.completed(value); });
            }
        });

        completedItems = computed(function () {
            return items().where("$.completed()").toArray();
        });

        return {
            items: items,
            newItem: newItem,
            addItem: addItem,
            checkAll: checkAll,
            completedItems: completedItems,
            removeCompletedItems: removeCompletedItems
        };
    };
});
```
Now we also need to perform the logic that will store and retrive items to/from `localStorage`. We use the
`computed` to keep track of changes to items, stringify items and add them to `localStorage`. We
do not need to return anything.

Also, if our `localStorage` is defined, then we need to `map` all of the to an `itemViewModel` using `toItemViewModel`.

<sub>__app/todo/viewmodels/todoViewModel.js__</sub>
```javascript
/*global define,localStorage */
define([
    'sandbox!todo',
    'app/todo/viewmodels/itemViewModel'
], function (
    sandbox,
    itemViewModel
) {
    'use strict';

    return function () {
        var observableArray = sandbox.mvvm.observableArray,
            observable = sandbox.mvvm.observable,
            has = sandbox.object.has,
            computed = sandbox.mvvm.computed,
            //properties
            items = observableArray(),
            newItem = observable(),
            checkAll,
            completedItems;

        function toItem(itemVM) {
            return {
                title: itemVM.title(),
                completed: itemVM.completed()
            };
        }

        function toItemViewModel(item) {
            return itemViewModel(item, items);
        }

        function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                items.push(itemViewModel({ title: item, completed: false }, items));
            }
            newItem("");
        }

        function removeCompletedItems() {
            completedItems().forEach(function (item) {
                item.remove();
            });
        }

        checkAll = computed({
            read: function () {
                return items().all("$.completed()");
            },
            write: function (value) {
                items().forEach(function (item) { item.completed(value); });
            }
        });

        completedItems = computed(function () {
            return items().where("$.completed()").toArray();
        });

        !!*if (has(localStorage['todos-scalejs'])) {
            items(JSON.parse(localStorage['todos-scalejs']).map(toItemViewModel));
        }**!

        !!*computed(function () {
            localStorage['todos-scalejs'] = JSON.stringify(items().map(toItem));
        });**!

        return {
            items: items,
            newItem: newItem,
            addItem: addItem,
            checkAll: checkAll,
            completedItems: completedItems,
            removeCompletedItems: removeCompletedItems
        };
    };
});
```

Since we have a `toItemViewModel` function, we can also simplify our `addItem` function by using that
instead of calling `itemViewModel` and passing the items.

<sub>__app/todo/viewmodels/todoViewModel.js__</sub>
```javascript
/*global define,localStorage */
define([
    'sandbox!todo',
    'app/todo/viewmodels/itemViewModel'
], function (
    sandbox,
    itemViewModel
) {
    'use strict';

    return function () {
        var observableArray = sandbox.mvvm.observableArray,
            observable = sandbox.mvvm.observable,
            has = sandbox.object.has,
            computed = sandbox.mvvm.computed,
            //properties
            items = observableArray(),
            newItem = observable(),
            checkAll,
            completedItems;

        function toItem(itemVM) {
            return {
                title: itemVM.title(),
                completed: itemVM.completed()
            };
        }

        function toItemViewModel(item) {
            return itemViewModel(item, items);
        }

        function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                !!*items.push(toItemViewModel({ title: item, completed: false }));**!
            }
            newItem("");
        }

        function removeCompletedItems() {
            completedItems().forEach(function (item) {
                item.remove();
            });
        }

        checkAll = computed({
            read: function () {
                return items().all("$.completed()");
            },
            write: function (value) {
                items().forEach(function (item) { item.completed(value); });
            }
        });

        completedItems = computed(function () {
            return items().where("$.completed()").toArray();
        });

        if (has(localStorage['todos-scalejs'])) {
            items(JSON.parse(localStorage['todos-scalejs']).map(toItemViewModel));
        }

        computed(function () {
            localStorage['todos-scalejs'] = JSON.stringify(items().map(toItem));
        });

        return {
            items: items,
            newItem: newItem,
            addItem: addItem,
            checkAll: checkAll,
            completedItems: completedItems,
            removeCompletedItems: removeCompletedItems
        };
    };
});
```

Now we have implemented persistence. 

<br>

### 14. Routing

Routing can be implemented via a scalejs [extension](./extension.html), ['scalejs.routing-history'](./routing.html).
To have access to the `routing` namespace, we must include it in our project via [NuGet](http://www.nuget.org/)

__Right-click__ on the _ToDoMVC_ project and select __Manage NuGet Packages__

![Select 'Manage NuGet Packages'](./nuget1.png)

Search for __scalejs.routing__ from the NuGet Package Manager window. 
At the time of this writing, routing is implemented using [history.js](https://github.com/browserstate/history.js/) so it is the only one available.
Select it and click "Install"

![scalejs.routing-historyjs](./nuget2.png)

We need to add the router to the app. Our _main_ state needs to be a child to a _router_ state so that the router 
can listen to and react to changes. 

The way routing is implemented is via states by defining a property on the state called `route`. This allows
the URL to be updated whenever the state is entered, and also when one navigates to a URL for a specific state
the state becomes active.

We need to change our __mainModule__ slightly to implement this change. We must register the `routerState()` which
we can get from `sandbox.routing` as a child of the `app` state. Then we must define our `main` state as 
a child of the `router` state.

<sub>__app/main/mainModule.js__</sub>
```javascript
/*global define */
define([
    'sandbox!main',
    'app/main/viewmodels/mainViewModel',
    'views!main',
    'bindings!main',
    'styles!main'
], function (
    sandbox,
    mainViewModel
) {
    'use strict';

    return function main() {
        var // imports
            root = sandbox.mvvm.root,
            template = sandbox.mvvm.template,
            registerStates = sandbox.state.registerStates,
            state = sandbox.state.builder.state,
            onEntry = sandbox.state.builder.onEntry,
            !!*routerState = sandbox.routing.routerState,
            route = sandbox.routing.route,**!
            // vars
            mainVM = mainViewModel();

        // Register application state for the module.
        registerStates('root',
            state('app',
                !!*routerState('main',**!
                        onEntry(function () {
                            // create state properties for rendering todo module templates
                            this.todoItems = mainVM.todoItems;
                            this.todoInput = mainVM.todoInput;
                            // Render viewModel using 'main_template' template 
                            // (defined in main.html) and show it in the `root` region.
                            root(template('main_template', mainVM));
                        })))));
    };
});
```

To make it possible to switch between _all_, _active_ and _completed_, we need to introduce an array containing
these options in viewmodel that the view will bind to using `foreach`.

<sub>__app/todo/views/todo.html__</sub>
```xml
<div id="todo_items_template">
    <section id="main" data-class="todo-visible">
        <input id="toggle-all" type="checkbox" data-bind="checked: checkAll">
        <label for="toggle-all">Mark all as complete</label>
        <ul id="todo-list" data-bind="foreach: items">
            <li data-class="todo-item">
                <div class="view">
                    <input class="toggle" type="checkbox" data-bind="checked: completed" />
                    <label data-bind="text: title"></label>
                    <button class="destroy" data-bind="click: remove"></button>
                </div>
                <input class="edit" data-class="todo-edit" />
            </li>
        </ul>
    </section>

    <footer id="footer" data-class="todo-visible">
        <span id="todo-count">
            <strong data-bind="text: items().length - completedItems().length"></strong>
            <!-- ko class:todo-count-text -->
            <!-- /ko -->
        </span>
        !!*<ul id="filters" data-bind="foreach: viewableOptions">
            <li>
                <a href="#" data-class="todo-view"></a>
            </li>
        </ul>**!
        <button id="clear-completed" data-class="todo-clear-completed"></button>
    </footer>
</div>

<div id="todo_input_template">
    <input id="new-todo" data-class="todo-input" placeholder="What needs to be done?" autofocus>
</div>
```

We need to define `viewableOptions` in the viewmodel. Each viewableOption has the name of what will be
displayed in the footer of our todo list (e.g. 'All', 'Active', and 'Completed') as well as a function
which will raise a statechart event. We will need to subscribe to and react to this event in our statechart.

<sub>__app/todo/viewmodel/todoViewModel.js__</sub>
```javascript
/*global define,localStorage */
define([
    'sandbox!todo',
    'app/todo/viewmodels/itemViewModel'
], function (
    sandbox,
    itemViewModel
) {
    'use strict';

    return function () {
        var observableArray = sandbox.mvvm.observableArray,
            observable = sandbox.mvvm.observable,
            has = sandbox.object.has,
            computed = sandbox.mvvm.computed,
			  !!*raise = sandbox.state.raise,**!
            //properties
            items = observableArray(),
            newItem = observable(),
            checkAll,
            completedItems!!*,
            viewableOptions;**!


        function toItem(itemVM) {
            return {
                title: itemVM.title(),
                completed: itemVM.completed()
            };
        }

        function toItemViewModel(item) {
            return itemViewModel(item, items);
        }

        function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                items.push(toItemViewModel({ title: item, completed: false }));
            }
            newItem("");
        }

        function removeCompletedItems() {
            completedItems().forEach(function (item) {
                item.remove();
            });
        }

        checkAll = computed({
            read: function () {
                return items().all("$.completed()");
            },
            write: function (value) {
                items().forEach(function (item) { item.completed(value); });
            }
        });

        completedItems = computed(function () {
            return items().where("$.completed()").toArray();
        });

        !!*viewableOptions = ['All', 'Active', 'Completed'].map(function (name) {
            return {
                name: name,
                raiseEvent: function () {
                    raise('todo.' + name);
                }
            };
        });**!

        if (has(localStorage['todos-scalejs'])) {
            items(JSON.parse(localStorage['todos-scalejs']).map(toItemViewModel));
        }

        computed(function () {
            localStorage['todos-scalejs'] = JSON.stringify(items().map(toItem));
        });

        return {
            items: items,
            newItem: newItem,
            addItem: addItem,
            checkAll: checkAll,
            completedItems: completedItems,
            removeCompletedItems: removeCompletedItems!!*,
            viewableOptions: viewableOptions**!
        };
    };
});
```

We also need to define the `todo-view` data-class.

<sub>__app/todo/bindings/todoBindings.js__</sub>
```javascript
/*global define */
/*jslint sloppy: true,unparam: true*/
define(function () {
    var ENTER_KEY = 13,
        ESCAPE_KEY = 27;

    return {
        'todo-visible': function () {
            return {
                visible: this.items().length > 0
            };
        },
        'todo-input': function () {
            var addItem = this.addItem;
            return {
                value: this.newItem,
                valueUpdate: 'afterkeydown',
                event: {
                    keyup: function (data, e) {
                        if (e.keyCode === ENTER_KEY) {
                            addItem();
                        }
                    }
                }
            };
        },
        'todo-item': function () {
            return {
                css: {
                    completed: this.completed,
                    editing: this.editMode
                },
                event: {
                    dblclick: this.beginEdit
                }
            };
        },
        'todo-edit': function () {
            var item = this;

            return {
                value: this.title,
                valueUpdate: 'afterkeydown',
                event: {
                    keyup: function (data, e) {
                        if (e.keyCode === ENTER_KEY) {
                            item.endEdit();
                        } else if (e.keyCode === ESCAPE_KEY) {
                            item.cancelEdit();
                        }
                    },
                    blur: function () {
                        item.endEdit();
                    }
                },
                hasFocus: this.editMode
            };
        },
        'todo-count-text': function () {
            return {
                text: (this.items().length  - this.completedItems().length === 1 ? 'item' : 'items') + ' left'
            };
        },
        'todo-clear-completed': function () {
            return {
                visible: this.completedItems().length > 0,
                text: 'Clear completed (' + this.completedItems().length + ')',
                click: this.removeCompletedItems
            };
        }!!*,
        'todo-view': function (ctx) {
            return {
                text: this.name,
                click: this.raiseEvent,
                css: { selected: ctx.$parent.currentView() === this.name }
            };
        }**!
    };
});
```

We will define three children states in our `todo` state: `todo.all`, `todo.active` and `todo.completed`.

When we enter these states, we need to update our viewModel to reflect the state that is entered.

We also need to define the transition that will occur when the events are raised. We use `gotoInternally` because
we do not want to exit the child state when we are switching between two child states.


<sub>__app/todo/todoModule.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo',
    'app/todo/viewmodels/todoViewModel',
    'bindings!todo',
    'views!todo',
    'styles!todo'
], function (
    sandbox,
    todoViewModel
) {
    'use strict';

    return function todoModule() {
        var // imports
            root = sandbox.mvvm.root,
            template = sandbox.mvvm.template,
            registerStates = sandbox.state.registerStates,
            state = sandbox.state.builder.state,
            onEntry = sandbox.state.builder.onEntry,
            !!*on = sandbox.state.builder.on,
            gotoInternally = sandbox.state.builder.gotoInternally,**!
            // vars
            todo = todoViewModel(sandbox);

        // Register application state for the module.
        registerStates('main',
            state('todo',
                onEntry(function () {
                    // pass the template bindings to the appropriate property
                    this.todoItems(template('todo_items_template', todo));
                    this.todoInput(template('todo_input_template', todo));
                })!!*,
                on('todo.All', gotoInternally('todo.all')),
                on('todo.Active', gotoInternally('todo.active')),
                on('todo.Completed', gotoInternally('todo.completed')),
                state('todo.all',
                    onEntry(function () {
                        todo.currentView("All");
                    })),
                state('todo.active',
                    onEntry(function () {
                        todo.currentView("Active");
                    })),
                state('todo.completed',
                    onEntry(function () {
                        todo.currentView("Completed");
                    }))));**!
    };
});

```

Which means we need to define `currentView` in our viewmodel.

<sub>__app/todo/viewmodel/todoViewModel.js__</sub>
```javascript
 return function () {
/*global define,localStorage */
define([
    'sandbox!todo',
    'app/todo/viewmodels/itemViewModel'
], function (
    sandbox,
    itemViewModel
) {
    'use strict';

    return function () {
        var observableArray = sandbox.mvvm.observableArray,
            observable = sandbox.mvvm.observable,
            has = sandbox.object.has,
            computed = sandbox.mvvm.computed,
            raise = sandbox.state.raise,
            //properties
            items = observableArray(),
            newItem = observable(),
            checkAll,
            completedItems,
            viewableOptions!!*,
            currentView = observable();**!


        function toItem(itemVM) {
            return {
                title: itemVM.title(),
                completed: itemVM.completed()
            };
        }

        function toItemViewModel(item) {
            return itemViewModel(item, items);
        }

        function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                items.push(toItemViewModel({ title: item, completed: false }));
            }
            newItem("");
        }

        function removeCompletedItems() {
            completedItems().forEach(function (item) {
                item.remove();
            });
        }

        checkAll = computed({
            read: function () {
                return items().all("$.completed()");
            },
            write: function (value) {
                items().forEach(function (item) { item.completed(value); });
            }
        });

        completedItems = computed(function () {
            return items().where("$.completed()").toArray();
        });

        viewableOptions = ['All', 'Active', 'Completed'].map(function (name) {
            return {
                name: name,
                raiseEvent: function () {
                    raise('todo.' + name);
                }
            };
        });

        if (has(localStorage['todos-scalejs'])) {
            items(JSON.parse(localStorage['todos-scalejs']).map(toItemViewModel));
        }

        computed(function () {
            localStorage['todos-scalejs'] = JSON.stringify(items().map(toItem));
        });

        return {
            items: items,
            newItem: newItem,
            addItem: addItem,
            checkAll: checkAll,
            completedItems: completedItems,
            removeCompletedItems: removeCompletedItems,
            viewableOptions: viewableOptions!!*,
            currentView: currentView**!
        };
    };
});
```

We need to modify how we are showing the items so that the correct items are being displayed while
also maintaining a list of all of the items. We will define a new computed, `viewableItems` which will
react to changes in `currentView` and `items`.

<sub>__app/todo/viewmodel/todoViewModel.js__</sub>
```javascript
/*global define,localStorage */
define([
    'sandbox!todo',
    'app/todo/viewmodels/itemViewModel'
], function (
    sandbox,
    itemViewModel
) {
    'use strict';

    return function () {
        var observableArray = sandbox.mvvm.observableArray,
            observable = sandbox.mvvm.observable,
            has = sandbox.object.has,
            computed = sandbox.mvvm.computed,
            raise = sandbox.state.raise,
            //properties
            items = observableArray(),
            newItem = observable(),
            checkAll,
            completedItems,
            viewableOptions,
            currentView = observable()!!*,
            viewableItems;**!


        function toItem(itemVM) {
            return {
                title: itemVM.title(),
                completed: itemVM.completed()
            };
        }

        function toItemViewModel(item) {
            return itemViewModel(item, items);
        }

        function addItem() {
            var item = newItem();
            if (has(item, "trim") && item.trim()) {
                items.push(toItemViewModel({ title: item, completed: false }));
            }
            newItem("");
        }

        function removeCompletedItems() {
            completedItems().forEach(function (item) {
                item.remove();
            });
        }

        checkAll = computed({
            read: function () {
                return items().all("$.completed()");
            },
            write: function (value) {
                items().forEach(function (item) { item.completed(value); });
            }
        });

        completedItems = computed(function () {
            return items().where("$.completed()").toArray();
        });

        viewableOptions = ['All', 'Active', 'Completed'].map(function (name) {
            return {
                name: name,
                raiseEvent: function () {
                    raise('todo.' + name);
                }
            };
        });

        !!*viewableItems = computed(function () {
            var view = currentView();

            if (view === 'Active') {
                return items().where("!$.completed()").toArray();
            }

            if (view === 'Completed') {
                return items().where("$.completed()").toArray();
            }

            return items();
        });**!

        if (has(localStorage['todos-scalejs'])) {
            items(JSON.parse(localStorage['todos-scalejs']).map(toItemViewModel));
        }

        computed(function () {
            localStorage['todos-scalejs'] = JSON.stringify(items().map(toItem));
        });

        return {
            items: items,
            newItem: newItem,
            addItem: addItem,
            checkAll: checkAll,
            completedItems: completedItems,
            removeCompletedItems: removeCompletedItems,
            viewableOptions: viewableOptions,
            currentView: currentView,
            !!*viewableItems: viewableItems**!
        };
    };
});
```

Now we need to bind our list to `viewableItems` instead of `items`.

<sub>__app/todo/views/todo.html__</sub>
```xml
<div id="todo_items_template">
    <section id="main" data-class="todo-visible">
        <input id="toggle-all" type="checkbox" data-bind="checked: checkAll">
        <label for="toggle-all">Mark all as complete</label>
        !!*<ul id="todo-list" data-bind="foreach: viewableItems">**!
            <li data-class="todo-item">
                <div class="view">
                    <input class="toggle" type="checkbox" data-bind="checked: completed" />
                    <label data-bind="text: title"></label>
                    <button class="destroy" data-bind="click: remove"></button>
                </div>
                <input class="edit" data-class="todo-edit" />
            </li>
        </ul>
    </section>

    <footer id="footer" data-class="todo-visible">
        <span id="todo-count">
            <strong data-bind="text: items().length"></strong>
            <!-- ko class:todo-count-text -->
            <!-- /ko -->
        </span>
        <ul id="filters" data-bind="foreach: viewableOptions">
            <li>
                <a href="#" data-class="todo-view"></a>
            </li>
        </ul>
        <button id="clear-completed" data-class="todo-clear-completed"></button>
    </footer>
</div>

<div id="todo_input_template">
    <input id="new-todo" data-class="todo-input" placeholder="What needs to be done?" autofocus>
</div>
```

So far, so good. Now we will begin to introduce our routing into our states by simply passing `route` into the state
with the text we would like to see in our URL. For the root, we specifiy '/'.

<sub>__app/todo/todoModule.js__</sub>
```javascript
/*global define */
define([
    'sandbox!todo',
    'app/todo/viewmodels/todoViewModel',
    'bindings!todo',
    'views!todo',
    'styles!todo'
], function (
    sandbox,
    todoViewModel
) {
    'use strict';

    return function todoModule() {
        var // imports
            root = sandbox.mvvm.root,
            template = sandbox.mvvm.template,
            registerStates = sandbox.state.registerStates,
            state = sandbox.state.builder.state,
            onEntry = sandbox.state.builder.onEntry,
            on = sandbox.state.builder.on,
            gotoInternally = sandbox.state.builder.gotoInternally,
            !!*route = sandbox.routing.route,**!
            // vars
            todo = todoViewModel(sandbox);

        // Register application state for the module.
        registerStates('main',
            state('todo',
                onEntry(function () {
                    // pass the template bindings to the appropriate property
                    this.todoItems(template('todo_items_template', todo));
                    this.todoInput(template('todo_input_template', todo));
                }),
                on('todo.All', gotoInternally('todo.all')),
                on('todo.Active', gotoInternally('todo.active')),
                on('todo.Completed', gotoInternally('todo.completed')),
                state('todo.all',
                    !!*route('/'),**!
                    onEntry(function () {
                        todo.currentView("All");
                    })),
                state('todo.active',
                    !!*route('active'),**!
                    onEntry(function () {
                        todo.currentView("Active");
                    })),
                state('todo.completed',
                    !!*route('completed'),**!
                    onEntry(function () {
                        todo.currentView("Completed");
                    }))));
    };
});

```

This is all that is needed to implement routing. Check it out for yourself! 

## Summary

You have completed the ToDoMVC tutorial. Have a Cookie!

![YUMM](https://fling.seas.upenn.edu/~asme/dynamic/wordpress/wp-content/uploads/2012/09/cookie.jpg)
